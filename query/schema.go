// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package query

import (
	"fmt"
	"io"
	"strconv"
)

type AlarmMessage struct {
	StartTime int64       `json:"startTime"`
	Scope     *Scope      `json:"scope,omitempty"`
	ID        string      `json:"id"`
	Message   string      `json:"message"`
	Events    []*Event    `json:"events"`
	Tags      []*KeyValue `json:"tags"`
}

type AlarmTag struct {
	Key   string  `json:"key"`
	Value *string `json:"value,omitempty"`
}

type AlarmTrend struct {
	NumOfAlarm []*int `json:"numOfAlarm"`
}

type Alarms struct {
	Msgs []*AlarmMessage `json:"msgs"`
}

type Attribute struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type BasicTrace struct {
	SegmentID     string   `json:"segmentId"`
	EndpointNames []string `json:"endpointNames"`
	Duration      int      `json:"duration"`
	Start         string   `json:"start"`
	IsError       *bool    `json:"isError,omitempty"`
	TraceIds      []string `json:"traceIds"`
}

type BatchMetricConditions struct {
	Name string   `json:"name"`
	Ids  []string `json:"ids"`
}

type BrowserErrorLog struct {
	Service            string        `json:"service"`
	ServiceVersion     string        `json:"serviceVersion"`
	Time               int64         `json:"time"`
	PagePath           string        `json:"pagePath"`
	Category           ErrorCategory `json:"category"`
	Grade              *string       `json:"grade,omitempty"`
	Message            *string       `json:"message,omitempty"`
	Line               *int          `json:"line,omitempty"`
	Col                *int          `json:"col,omitempty"`
	Stack              *string       `json:"stack,omitempty"`
	ErrorURL           *string       `json:"errorUrl,omitempty"`
	FirstReportedError bool          `json:"firstReportedError"`
}

type BrowserErrorLogQueryCondition struct {
	ServiceID        *string        `json:"serviceId,omitempty"`
	ServiceVersionID *string        `json:"serviceVersionId,omitempty"`
	PagePathID       *string        `json:"pagePathId,omitempty"`
	Category         *ErrorCategory `json:"category,omitempty"`
	QueryDuration    *Duration      `json:"queryDuration,omitempty"`
	Paging           *Pagination    `json:"paging,omitempty"`
}

type BrowserErrorLogs struct {
	Logs []*BrowserErrorLog `json:"logs"`
}

type Bucket struct {
	Min string `json:"min"`
	Max string `json:"max"`
}

type Call struct {
	Source           string        `json:"source"`
	SourceComponents []string      `json:"sourceComponents"`
	Target           string        `json:"target"`
	TargetComponents []string      `json:"targetComponents"`
	ID               string        `json:"id"`
	DetectPoints     []DetectPoint `json:"detectPoints"`
}

type ContinuousProfilingMonitoringInstance struct {
	ID                   string                                  `json:"id"`
	Name                 string                                  `json:"name"`
	Attributes           []*Attribute                            `json:"attributes"`
	TriggeredCount       int                                     `json:"triggeredCount"`
	LastTriggerTimestamp *int64                                  `json:"lastTriggerTimestamp,omitempty"`
	Processes            []*ContinuousProfilingMonitoringProcess `json:"processes"`
}

type ContinuousProfilingMonitoringProcess struct {
	ID                   string   `json:"id"`
	Name                 string   `json:"name"`
	DetectType           string   `json:"detectType"`
	Labels               []string `json:"labels"`
	TriggeredCount       int      `json:"triggeredCount"`
	LastTriggerTimestamp *int64   `json:"lastTriggerTimestamp,omitempty"`
}

type ContinuousProfilingPolicyCreation struct {
	ServiceID string                                     `json:"serviceId"`
	Targets   []*ContinuousProfilingPolicyTargetCreation `json:"targets"`
}

type ContinuousProfilingPolicyItem struct {
	Type      ContinuousProfilingMonitorType `json:"type"`
	Threshold string                         `json:"threshold"`
	Period    int                            `json:"period"`
	Count     int                            `json:"count"`
	URIList   []string                       `json:"uriList"`
	URIRegex  *string                        `json:"uriRegex,omitempty"`
}

type ContinuousProfilingPolicyItemCreation struct {
	Type      ContinuousProfilingMonitorType `json:"type"`
	Threshold string                         `json:"threshold"`
	Period    int                            `json:"period"`
	Count     int                            `json:"count"`
	URIList   []string                       `json:"uriList"`
	URIRegex  *string                        `json:"uriRegex,omitempty"`
}

type ContinuousProfilingPolicyTarget struct {
	Type                 ContinuousProfilingTargetType    `json:"type"`
	CheckItems           []*ContinuousProfilingPolicyItem `json:"checkItems"`
	TriggeredCount       int                              `json:"triggeredCount"`
	LastTriggerTimestamp *int64                           `json:"lastTriggerTimestamp,omitempty"`
}

type ContinuousProfilingPolicyTargetCreation struct {
	TargetType ContinuousProfilingTargetType            `json:"targetType"`
	CheckItems []*ContinuousProfilingPolicyItemCreation `json:"checkItems"`
}

type ContinuousProfilingSetResult struct {
	Status      bool    `json:"status"`
	ErrorReason *string `json:"errorReason,omitempty"`
}

type ContinuousProfilingSingleValueCause struct {
	Threshold int64 `json:"threshold"`
	Current   int64 `json:"current"`
}

type ContinuousProfilingTriggeredCause struct {
	Type        ContinuousProfilingMonitorType       `json:"type"`
	SingleValue *ContinuousProfilingSingleValueCause `json:"singleValue,omitempty"`
	URI         *ContinuousProfilingURICause         `json:"uri,omitempty"`
	Message     string                               `json:"message"`
}

type ContinuousProfilingURICause struct {
	URIRegex  *string `json:"uriRegex,omitempty"`
	URIPath   *string `json:"uriPath,omitempty"`
	Threshold int64   `json:"threshold"`
	Current   int64   `json:"current"`
}

type DashboardConfiguration struct {
	ID            string `json:"id"`
	Configuration string `json:"configuration"`
}

type DashboardSetting struct {
	ID            string `json:"id"`
	Configuration string `json:"configuration"`
}

type Database struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	Type string `json:"type"`
}

type Duration struct {
	Start string `json:"start"`
	End   string `json:"end"`
	Step  Step   `json:"step"`
}

type EBPFNetworkDataCollectingSettings struct {
	RequireCompleteRequest  bool `json:"requireCompleteRequest"`
	MaxRequestSize          *int `json:"maxRequestSize,omitempty"`
	RequireCompleteResponse bool `json:"requireCompleteResponse"`
	MaxResponseSize         *int `json:"maxResponseSize,omitempty"`
}

type EBPFNetworkKeepProfilingResult struct {
	Status      bool    `json:"status"`
	ErrorReason *string `json:"errorReason,omitempty"`
}

type EBPFNetworkSamplingRule struct {
	URIRegex    *string                            `json:"uriRegex,omitempty"`
	MinDuration *int                               `json:"minDuration,omitempty"`
	When4xx     bool                               `json:"when4xx"`
	When5xx     bool                               `json:"when5xx"`
	Settings    *EBPFNetworkDataCollectingSettings `json:"settings,omitempty"`
}

type EBPFProfilingAnalyzation struct {
	Tip   *string              `json:"tip,omitempty"`
	Trees []*EBPFProfilingTree `json:"trees"`
}

type EBPFProfilingAnalyzeTimeRange struct {
	Start int64 `json:"start"`
	End   int64 `json:"end"`
}

type EBPFProfilingNetworkTaskRequest struct {
	InstanceID string                     `json:"instanceId"`
	Samplings  []*EBPFNetworkSamplingRule `json:"samplings"`
}

type EBPFProfilingSchedule struct {
	ScheduleID string   `json:"scheduleId"`
	TaskID     string   `json:"taskId"`
	Process    *Process `json:"process,omitempty"`
	StartTime  int64    `json:"startTime"`
	EndTime    int64    `json:"endTime"`
}

type EBPFProfilingStackElement struct {
	ID        string                 `json:"id"`
	ParentID  string                 `json:"parentId"`
	Symbol    string                 `json:"symbol"`
	StackType EBPFProfilingStackType `json:"stackType"`
	DumpCount int64                  `json:"dumpCount"`
}

type EBPFProfilingTask struct {
	TaskID                    string                               `json:"taskId"`
	ServiceID                 string                               `json:"serviceId"`
	ServiceName               string                               `json:"serviceName"`
	ServiceInstanceID         *string                              `json:"serviceInstanceId,omitempty"`
	ServiceInstanceName       *string                              `json:"serviceInstanceName,omitempty"`
	ProcessLabels             []string                             `json:"processLabels"`
	ProcessID                 *string                              `json:"processId,omitempty"`
	ProcessName               *string                              `json:"processName,omitempty"`
	TaskStartTime             int64                                `json:"taskStartTime"`
	TriggerType               EBPFProfilingTriggerType             `json:"triggerType"`
	FixedTriggerDuration      *int64                               `json:"fixedTriggerDuration,omitempty"`
	ContinuousProfilingCauses []*ContinuousProfilingTriggeredCause `json:"continuousProfilingCauses"`
	TargetType                EBPFProfilingTargetType              `json:"targetType"`
	CreateTime                int64                                `json:"createTime"`
}

type EBPFProfilingTaskCreationResult struct {
	Status      bool    `json:"status"`
	ErrorReason *string `json:"errorReason,omitempty"`
	ID          *string `json:"id,omitempty"`
}

type EBPFProfilingTaskFixedTimeCreationRequest struct {
	ServiceID     string                  `json:"serviceId"`
	ProcessLabels []string                `json:"processLabels"`
	StartTime     int64                   `json:"startTime"`
	Duration      int                     `json:"duration"`
	TargetType    EBPFProfilingTargetType `json:"targetType"`
}

type EBPFProfilingTaskPrepare struct {
	CouldProfiling bool     `json:"couldProfiling"`
	ProcessLabels  []string `json:"processLabels"`
}

type EBPFProfilingTree struct {
	Elements []*EBPFProfilingStackElement `json:"elements"`
}

type Endpoint struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type EndpointInfo struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	ServiceID   string `json:"serviceId"`
	ServiceName string `json:"serviceName"`
}

type EndpointNode struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	ServiceID   string  `json:"serviceId"`
	ServiceName string  `json:"serviceName"`
	Type        *string `json:"type,omitempty"`
	IsReal      bool    `json:"isReal"`
}

type EndpointTopology struct {
	Nodes []*EndpointNode `json:"nodes"`
	Calls []*Call         `json:"calls"`
}

type Entity struct {
	Scope                   *Scope  `json:"scope,omitempty"`
	ServiceName             *string `json:"serviceName,omitempty"`
	Normal                  *bool   `json:"normal,omitempty"`
	ServiceInstanceName     *string `json:"serviceInstanceName,omitempty"`
	EndpointName            *string `json:"endpointName,omitempty"`
	ProcessName             *string `json:"processName,omitempty"`
	DestServiceName         *string `json:"destServiceName,omitempty"`
	DestNormal              *bool   `json:"destNormal,omitempty"`
	DestServiceInstanceName *string `json:"destServiceInstanceName,omitempty"`
	DestEndpointName        *string `json:"destEndpointName,omitempty"`
	DestProcessName         *string `json:"destProcessName,omitempty"`
}

type Event struct {
	UUID       string      `json:"uuid"`
	Source     *Source     `json:"source,omitempty"`
	Name       string      `json:"name"`
	Type       EventType   `json:"type"`
	Message    *string     `json:"message,omitempty"`
	Parameters []*KeyValue `json:"parameters"`
	StartTime  int64       `json:"startTime"`
	EndTime    *int64      `json:"endTime,omitempty"`
	Layer      string      `json:"layer"`
}

type EventQueryCondition struct {
	UUID   *string      `json:"uuid,omitempty"`
	Source *SourceInput `json:"source,omitempty"`
	Name   *string      `json:"name,omitempty"`
	Type   *EventType   `json:"type,omitempty"`
	Time   *Duration    `json:"time,omitempty"`
	Order  *Order       `json:"order,omitempty"`
	Layer  *string      `json:"layer,omitempty"`
	Paging *Pagination  `json:"paging,omitempty"`
}

type Events struct {
	Events []*Event `json:"events"`
}

type ExpressionResult struct {
	Type    ExpressionResultType `json:"type"`
	Results []*MQEValues         `json:"results"`
	Error   *string              `json:"error,omitempty"`
}

type HealthStatus struct {
	Score   int     `json:"score"`
	Details *string `json:"details,omitempty"`
}

type HeatMap struct {
	Values  []*HeatMapColumn `json:"values"`
	Buckets []*Bucket        `json:"buckets"`
}

type HeatMapColumn struct {
	ID     string  `json:"id"`
	Values []int64 `json:"values"`
}

type Instant struct {
	Seconds int64 `json:"seconds"`
	Nanos   int   `json:"nanos"`
}

type IntValues struct {
	Values []*KVInt `json:"values"`
}

type KVInt struct {
	ID           string `json:"id"`
	Value        int64  `json:"value"`
	IsEmptyValue bool   `json:"isEmptyValue"`
}

type KeyNumericValue struct {
	Key   string `json:"key"`
	Value int64  `json:"value"`
}

type KeyValue struct {
	Key   string  `json:"key"`
	Value *string `json:"value,omitempty"`
}

type Log struct {
	ServiceName         *string     `json:"serviceName,omitempty"`
	ServiceID           *string     `json:"serviceId,omitempty"`
	ServiceInstanceName *string     `json:"serviceInstanceName,omitempty"`
	ServiceInstanceID   *string     `json:"serviceInstanceId,omitempty"`
	EndpointName        *string     `json:"endpointName,omitempty"`
	EndpointID          *string     `json:"endpointId,omitempty"`
	TraceID             *string     `json:"traceId,omitempty"`
	Timestamp           int64       `json:"timestamp"`
	ContentType         ContentType `json:"contentType"`
	Content             *string     `json:"content,omitempty"`
	Tags                []*KeyValue `json:"tags"`
}

type LogEntity struct {
	Time int64       `json:"time"`
	Data []*KeyValue `json:"data"`
}

type LogQueryCondition struct {
	ServiceID                  *string              `json:"serviceId,omitempty"`
	ServiceInstanceID          *string              `json:"serviceInstanceId,omitempty"`
	EndpointID                 *string              `json:"endpointId,omitempty"`
	RelatedTrace               *TraceScopeCondition `json:"relatedTrace,omitempty"`
	QueryDuration              *Duration            `json:"queryDuration,omitempty"`
	Paging                     *Pagination          `json:"paging,omitempty"`
	Tags                       []*LogTag            `json:"tags"`
	KeywordsOfContent          []string             `json:"keywordsOfContent"`
	ExcludingKeywordsOfContent []string             `json:"excludingKeywordsOfContent"`
	QueryOrder                 *Order               `json:"queryOrder,omitempty"`
}

type LogTag struct {
	Key   string  `json:"key"`
	Value *string `json:"value,omitempty"`
}

type LogTestMetrics struct {
	Name      string      `json:"name"`
	Tags      []*KeyValue `json:"tags"`
	Value     int64       `json:"value"`
	Timestamp int64       `json:"timestamp"`
}

type LogTestRequest struct {
	Log string `json:"log"`
	Dsl string `json:"dsl"`
}

type LogTestResponse struct {
	Log     *Log              `json:"log,omitempty"`
	Metrics []*LogTestMetrics `json:"metrics"`
}

type Logs struct {
	ErrorReason *string `json:"errorReason,omitempty"`
	Logs        []*Log  `json:"logs"`
}

type MQEValue struct {
	ID      *string `json:"id,omitempty"`
	Value   *string `json:"value,omitempty"`
	TraceID *string `json:"traceID,omitempty"`
}

type MQEValues struct {
	Metric *Metadata   `json:"metric,omitempty"`
	Values []*MQEValue `json:"values"`
}

type MenuItem struct {
	Title        string      `json:"title"`
	Icon         *string     `json:"icon,omitempty"`
	Layer        string      `json:"layer"`
	Activate     bool        `json:"activate"`
	SubItems     []*MenuItem `json:"subItems"`
	Description  *string     `json:"description,omitempty"`
	DocumentLink *string     `json:"documentLink,omitempty"`
	I18nKey      *string     `json:"i18nKey,omitempty"`
}

type Metadata struct {
	Labels []*KeyValue `json:"labels"`
}

type MetricCondition struct {
	Name string  `json:"name"`
	ID   *string `json:"id,omitempty"`
}

type MetricDefinition struct {
	Name    string      `json:"name"`
	Type    MetricsType `json:"type"`
	Catalog *string     `json:"catalog,omitempty"`
}

type MetricsCondition struct {
	Name   string  `json:"name"`
	Entity *Entity `json:"entity,omitempty"`
}

type MetricsValues struct {
	Label  *string    `json:"label,omitempty"`
	Values *IntValues `json:"values,omitempty"`
}

type NewDashboardSetting struct {
	Configuration string `json:"configuration"`
}

type Node struct {
	ID     string  `json:"id"`
	Name   string  `json:"name"`
	Type   *string `json:"type,omitempty"`
	IsReal bool    `json:"isReal"`
}

type NullableValue struct {
	Value        int64 `json:"value"`
	IsEmptyValue bool  `json:"isEmptyValue"`
}

type OndemandContainergQueryCondition struct {
	ServiceInstanceID *string `json:"serviceInstanceId,omitempty"`
}

type OndemandLogQueryCondition struct {
	ServiceInstanceID          *string   `json:"serviceInstanceId,omitempty"`
	Container                  string    `json:"container"`
	Duration                   *Duration `json:"duration,omitempty"`
	KeywordsOfContent          []string  `json:"keywordsOfContent"`
	ExcludingKeywordsOfContent []string  `json:"excludingKeywordsOfContent"`
}

type Pagination struct {
	PageNum  *int `json:"pageNum,omitempty"`
	PageSize int  `json:"pageSize"`
}

type PodContainers struct {
	ErrorReason *string  `json:"errorReason,omitempty"`
	Containers  []string `json:"containers"`
}

type Process struct {
	ID           string       `json:"id"`
	Name         string       `json:"name"`
	ServiceID    string       `json:"serviceId"`
	ServiceName  string       `json:"serviceName"`
	InstanceID   string       `json:"instanceId"`
	InstanceName string       `json:"instanceName"`
	AgentID      string       `json:"agentId"`
	DetectType   string       `json:"detectType"`
	Attributes   []*Attribute `json:"attributes"`
	Labels       []string     `json:"labels"`
}

type ProcessNode struct {
	ID                  string `json:"id"`
	ServiceID           string `json:"serviceId"`
	ServiceName         string `json:"serviceName"`
	ServiceInstanceID   string `json:"serviceInstanceId"`
	ServiceInstanceName string `json:"serviceInstanceName"`
	Name                string `json:"name"`
	IsReal              bool   `json:"isReal"`
}

type ProcessTopology struct {
	Nodes []*ProcessNode `json:"nodes"`
	Calls []*Call        `json:"calls"`
}

type ProfileAnalyzation struct {
	Tip   *string             `json:"tip,omitempty"`
	Trees []*ProfileStackTree `json:"trees"`
}

type ProfileAnalyzeTimeRange struct {
	Start int64 `json:"start"`
	End   int64 `json:"end"`
}

type ProfileStackElement struct {
	ID                    string `json:"id"`
	ParentID              string `json:"parentId"`
	CodeSignature         string `json:"codeSignature"`
	Duration              int    `json:"duration"`
	DurationChildExcluded int    `json:"durationChildExcluded"`
	Count                 int    `json:"count"`
}

type ProfileStackTree struct {
	Elements []*ProfileStackElement `json:"elements"`
}

type ProfileTask struct {
	ID                   string            `json:"id"`
	ServiceID            string            `json:"serviceId"`
	ServiceName          string            `json:"serviceName"`
	EndpointName         string            `json:"endpointName"`
	StartTime            int64             `json:"startTime"`
	Duration             int               `json:"duration"`
	MinDurationThreshold int               `json:"minDurationThreshold"`
	DumpPeriod           int               `json:"dumpPeriod"`
	MaxSamplingCount     int               `json:"maxSamplingCount"`
	Logs                 []*ProfileTaskLog `json:"logs"`
}

type ProfileTaskCreationRequest struct {
	ServiceID            string `json:"serviceId"`
	EndpointName         string `json:"endpointName"`
	StartTime            *int64 `json:"startTime,omitempty"`
	Duration             int    `json:"duration"`
	MinDurationThreshold int    `json:"minDurationThreshold"`
	DumpPeriod           int    `json:"dumpPeriod"`
	MaxSamplingCount     int    `json:"maxSamplingCount"`
}

type ProfileTaskCreationResult struct {
	ErrorReason *string `json:"errorReason,omitempty"`
	ID          *string `json:"id,omitempty"`
}

type ProfileTaskLog struct {
	ID            string                      `json:"id"`
	InstanceID    string                      `json:"instanceId"`
	InstanceName  string                      `json:"instanceName"`
	OperationType ProfileTaskLogOperationType `json:"operationType"`
	OperationTime int64                       `json:"operationTime"`
}

type ProfiledSegment struct {
	Spans []*ProfiledSpan `json:"spans"`
}

type ProfiledSpan struct {
	SpanID              int          `json:"spanId"`
	ParentSpanID        int          `json:"parentSpanId"`
	SegmentID           string       `json:"segmentId"`
	Refs                []*Ref       `json:"refs"`
	ServiceCode         string       `json:"serviceCode"`
	ServiceInstanceName string       `json:"serviceInstanceName"`
	StartTime           int64        `json:"startTime"`
	EndTime             int64        `json:"endTime"`
	EndpointName        *string      `json:"endpointName,omitempty"`
	Type                string       `json:"type"`
	Peer                *string      `json:"peer,omitempty"`
	Component           *string      `json:"component,omitempty"`
	IsError             *bool        `json:"isError,omitempty"`
	Layer               *string      `json:"layer,omitempty"`
	Tags                []*KeyValue  `json:"tags"`
	Logs                []*LogEntity `json:"logs"`
	Profiled            bool         `json:"profiled"`
}

type ProfiledTraceSegments struct {
	TraceID       string          `json:"traceId"`
	InstanceID    string          `json:"instanceId"`
	InstanceName  string          `json:"instanceName"`
	EndpointNames []string        `json:"endpointNames"`
	Duration      int             `json:"duration"`
	Start         string          `json:"start"`
	Spans         []*ProfiledSpan `json:"spans"`
}

type Record struct {
	Name  string  `json:"name"`
	ID    string  `json:"id"`
	Value *string `json:"value,omitempty"`
	RefID *string `json:"refId,omitempty"`
}

type RecordCondition struct {
	Name         string  `json:"name"`
	ParentEntity *Entity `json:"parentEntity,omitempty"`
	TopN         int     `json:"topN"`
	Order        Order   `json:"order"`
}

type Ref struct {
	TraceID         string  `json:"traceId"`
	ParentSegmentID string  `json:"parentSegmentId"`
	ParentSpanID    int     `json:"parentSpanId"`
	Type            RefType `json:"type"`
}

type SegmentProfileAnalyzeQuery struct {
	SegmentID string                   `json:"segmentId"`
	TimeRange *ProfileAnalyzeTimeRange `json:"timeRange,omitempty"`
}

type SelectedRecord struct {
	Name  string  `json:"name"`
	ID    string  `json:"id"`
	Value *string `json:"value,omitempty"`
	RefID *string `json:"refId,omitempty"`
}

type Service struct {
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	Group     string   `json:"group"`
	ShortName string   `json:"shortName"`
	Layers    []string `json:"layers"`
	Normal    *bool    `json:"normal,omitempty"`
}

type ServiceInstance struct {
	ID           string       `json:"id"`
	Name         string       `json:"name"`
	Attributes   []*Attribute `json:"attributes"`
	Language     Language     `json:"language"`
	InstanceUUID string       `json:"instanceUUID"`
}

type ServiceInstanceNode struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	ServiceID   string  `json:"serviceId"`
	ServiceName string  `json:"serviceName"`
	Type        *string `json:"type,omitempty"`
	IsReal      bool    `json:"isReal"`
}

type ServiceInstanceTopology struct {
	Nodes []*ServiceInstanceNode `json:"nodes"`
	Calls []*Call                `json:"calls"`
}

type Source struct {
	Service         *string `json:"service,omitempty"`
	ServiceInstance *string `json:"serviceInstance,omitempty"`
	Endpoint        *string `json:"endpoint,omitempty"`
}

type SourceInput struct {
	Service         *string `json:"service,omitempty"`
	ServiceInstance *string `json:"serviceInstance,omitempty"`
	Endpoint        *string `json:"endpoint,omitempty"`
}

type Span struct {
	TraceID             string               `json:"traceId"`
	SegmentID           string               `json:"segmentId"`
	SpanID              int                  `json:"spanId"`
	ParentSpanID        int                  `json:"parentSpanId"`
	Refs                []*Ref               `json:"refs"`
	ServiceCode         string               `json:"serviceCode"`
	ServiceInstanceName string               `json:"serviceInstanceName"`
	StartTime           int64                `json:"startTime"`
	EndTime             int64                `json:"endTime"`
	EndpointName        *string              `json:"endpointName,omitempty"`
	Type                string               `json:"type"`
	Peer                *string              `json:"peer,omitempty"`
	Component           *string              `json:"component,omitempty"`
	IsError             *bool                `json:"isError,omitempty"`
	Layer               *string              `json:"layer,omitempty"`
	Tags                []*KeyValue          `json:"tags"`
	Logs                []*LogEntity         `json:"logs"`
	AttachedEvents      []*SpanAttachedEvent `json:"attachedEvents"`
}

type SpanAttachedEvent struct {
	StartTime *Instant           `json:"startTime,omitempty"`
	Event     string             `json:"event"`
	EndTime   *Instant           `json:"endTime,omitempty"`
	Tags      []*KeyValue        `json:"tags"`
	Summary   []*KeyNumericValue `json:"summary"`
}

type SpanTag struct {
	Key   string  `json:"key"`
	Value *string `json:"value,omitempty"`
}

type TemplateChangeStatus struct {
	ID      string  `json:"id"`
	Status  bool    `json:"status"`
	Message *string `json:"message,omitempty"`
}

type Thermodynamic struct {
	Nodes     [][]*int `json:"nodes"`
	AxisYStep int      `json:"axisYStep"`
}

type TimeInfo struct {
	Timezone         *string `json:"timezone,omitempty"`
	CurrentTimestamp *int64  `json:"currentTimestamp,omitempty"`
}

type TopNCondition struct {
	Name          string  `json:"name"`
	ParentService *string `json:"parentService,omitempty"`
	Normal        *bool   `json:"normal,omitempty"`
	Scope         *Scope  `json:"scope,omitempty"`
	TopN          int     `json:"topN"`
	Order         Order   `json:"order"`
}

type TopNEntity struct {
	Name  string `json:"name"`
	ID    string `json:"id"`
	Value int64  `json:"value"`
}

type TopNRecord struct {
	Statement *string `json:"statement,omitempty"`
	Latency   int64   `json:"latency"`
	TraceID   *string `json:"traceId,omitempty"`
}

type TopNRecordsCondition struct {
	ServiceID  string    `json:"serviceId"`
	MetricName string    `json:"metricName"`
	TopN       int       `json:"topN"`
	Order      Order     `json:"order"`
	Duration   *Duration `json:"duration,omitempty"`
}

type Topology struct {
	Nodes []*Node `json:"nodes"`
	Calls []*Call `json:"calls"`
}

type Trace struct {
	Spans []*Span `json:"spans"`
}

type TraceBrief struct {
	Traces []*BasicTrace `json:"traces"`
}

type TraceQueryCondition struct {
	ServiceID         *string     `json:"serviceId,omitempty"`
	ServiceInstanceID *string     `json:"serviceInstanceId,omitempty"`
	TraceID           *string     `json:"traceId,omitempty"`
	EndpointID        *string     `json:"endpointId,omitempty"`
	QueryDuration     *Duration   `json:"queryDuration,omitempty"`
	MinTraceDuration  *int        `json:"minTraceDuration,omitempty"`
	MaxTraceDuration  *int        `json:"maxTraceDuration,omitempty"`
	TraceState        TraceState  `json:"traceState"`
	QueryOrder        QueryOrder  `json:"queryOrder"`
	Tags              []*SpanTag  `json:"tags"`
	Paging            *Pagination `json:"paging,omitempty"`
}

type TraceScopeCondition struct {
	TraceID   string  `json:"traceId"`
	SegmentID *string `json:"segmentId,omitempty"`
	SpanID    *int    `json:"spanId,omitempty"`
}

type ContentType string

const (
	ContentTypeText ContentType = "TEXT"
	ContentTypeJSON ContentType = "JSON"
	ContentTypeYaml ContentType = "YAML"
)

var AllContentType = []ContentType{
	ContentTypeText,
	ContentTypeJSON,
	ContentTypeYaml,
}

func (e ContentType) IsValid() bool {
	switch e {
	case ContentTypeText, ContentTypeJSON, ContentTypeYaml:
		return true
	}
	return false
}

func (e ContentType) String() string {
	return string(e)
}

func (e *ContentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContentType", str)
	}
	return nil
}

func (e ContentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContinuousProfilingMonitorType string

const (
	ContinuousProfilingMonitorTypeProcessCPU          ContinuousProfilingMonitorType = "PROCESS_CPU"
	ContinuousProfilingMonitorTypeProcessThreadCount  ContinuousProfilingMonitorType = "PROCESS_THREAD_COUNT"
	ContinuousProfilingMonitorTypeSystemLoad          ContinuousProfilingMonitorType = "SYSTEM_LOAD"
	ContinuousProfilingMonitorTypeHTTPErrorRate       ContinuousProfilingMonitorType = "HTTP_ERROR_RATE"
	ContinuousProfilingMonitorTypeHTTPAvgResponseTime ContinuousProfilingMonitorType = "HTTP_AVG_RESPONSE_TIME"
)

var AllContinuousProfilingMonitorType = []ContinuousProfilingMonitorType{
	ContinuousProfilingMonitorTypeProcessCPU,
	ContinuousProfilingMonitorTypeProcessThreadCount,
	ContinuousProfilingMonitorTypeSystemLoad,
	ContinuousProfilingMonitorTypeHTTPErrorRate,
	ContinuousProfilingMonitorTypeHTTPAvgResponseTime,
}

func (e ContinuousProfilingMonitorType) IsValid() bool {
	switch e {
	case ContinuousProfilingMonitorTypeProcessCPU, ContinuousProfilingMonitorTypeProcessThreadCount, ContinuousProfilingMonitorTypeSystemLoad, ContinuousProfilingMonitorTypeHTTPErrorRate, ContinuousProfilingMonitorTypeHTTPAvgResponseTime:
		return true
	}
	return false
}

func (e ContinuousProfilingMonitorType) String() string {
	return string(e)
}

func (e *ContinuousProfilingMonitorType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContinuousProfilingMonitorType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContinuousProfilingMonitorType", str)
	}
	return nil
}

func (e ContinuousProfilingMonitorType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContinuousProfilingTargetType string

const (
	ContinuousProfilingTargetTypeOnCPU   ContinuousProfilingTargetType = "ON_CPU"
	ContinuousProfilingTargetTypeOffCPU  ContinuousProfilingTargetType = "OFF_CPU"
	ContinuousProfilingTargetTypeNetwork ContinuousProfilingTargetType = "NETWORK"
)

var AllContinuousProfilingTargetType = []ContinuousProfilingTargetType{
	ContinuousProfilingTargetTypeOnCPU,
	ContinuousProfilingTargetTypeOffCPU,
	ContinuousProfilingTargetTypeNetwork,
}

func (e ContinuousProfilingTargetType) IsValid() bool {
	switch e {
	case ContinuousProfilingTargetTypeOnCPU, ContinuousProfilingTargetTypeOffCPU, ContinuousProfilingTargetTypeNetwork:
		return true
	}
	return false
}

func (e ContinuousProfilingTargetType) String() string {
	return string(e)
}

func (e *ContinuousProfilingTargetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContinuousProfilingTargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContinuousProfilingTargetType", str)
	}
	return nil
}

func (e ContinuousProfilingTargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DetectPoint string

const (
	DetectPointClient DetectPoint = "CLIENT"
	DetectPointServer DetectPoint = "SERVER"
	DetectPointProxy  DetectPoint = "PROXY"
)

var AllDetectPoint = []DetectPoint{
	DetectPointClient,
	DetectPointServer,
	DetectPointProxy,
}

func (e DetectPoint) IsValid() bool {
	switch e {
	case DetectPointClient, DetectPointServer, DetectPointProxy:
		return true
	}
	return false
}

func (e DetectPoint) String() string {
	return string(e)
}

func (e *DetectPoint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DetectPoint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DetectPoint", str)
	}
	return nil
}

func (e DetectPoint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EBPFProfilingAnalyzeAggregateType string

const (
	EBPFProfilingAnalyzeAggregateTypeDuration EBPFProfilingAnalyzeAggregateType = "DURATION"
	EBPFProfilingAnalyzeAggregateTypeCount    EBPFProfilingAnalyzeAggregateType = "COUNT"
)

var AllEBPFProfilingAnalyzeAggregateType = []EBPFProfilingAnalyzeAggregateType{
	EBPFProfilingAnalyzeAggregateTypeDuration,
	EBPFProfilingAnalyzeAggregateTypeCount,
}

func (e EBPFProfilingAnalyzeAggregateType) IsValid() bool {
	switch e {
	case EBPFProfilingAnalyzeAggregateTypeDuration, EBPFProfilingAnalyzeAggregateTypeCount:
		return true
	}
	return false
}

func (e EBPFProfilingAnalyzeAggregateType) String() string {
	return string(e)
}

func (e *EBPFProfilingAnalyzeAggregateType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EBPFProfilingAnalyzeAggregateType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EBPFProfilingAnalyzeAggregateType", str)
	}
	return nil
}

func (e EBPFProfilingAnalyzeAggregateType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EBPFProfilingStackType string

const (
	EBPFProfilingStackTypeKernelSpace EBPFProfilingStackType = "KERNEL_SPACE"
	EBPFProfilingStackTypeUserSpace   EBPFProfilingStackType = "USER_SPACE"
)

var AllEBPFProfilingStackType = []EBPFProfilingStackType{
	EBPFProfilingStackTypeKernelSpace,
	EBPFProfilingStackTypeUserSpace,
}

func (e EBPFProfilingStackType) IsValid() bool {
	switch e {
	case EBPFProfilingStackTypeKernelSpace, EBPFProfilingStackTypeUserSpace:
		return true
	}
	return false
}

func (e EBPFProfilingStackType) String() string {
	return string(e)
}

func (e *EBPFProfilingStackType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EBPFProfilingStackType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EBPFProfilingStackType", str)
	}
	return nil
}

func (e EBPFProfilingStackType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EBPFProfilingTargetType string

const (
	EBPFProfilingTargetTypeOnCPU   EBPFProfilingTargetType = "ON_CPU"
	EBPFProfilingTargetTypeOffCPU  EBPFProfilingTargetType = "OFF_CPU"
	EBPFProfilingTargetTypeNetwork EBPFProfilingTargetType = "NETWORK"
)

var AllEBPFProfilingTargetType = []EBPFProfilingTargetType{
	EBPFProfilingTargetTypeOnCPU,
	EBPFProfilingTargetTypeOffCPU,
	EBPFProfilingTargetTypeNetwork,
}

func (e EBPFProfilingTargetType) IsValid() bool {
	switch e {
	case EBPFProfilingTargetTypeOnCPU, EBPFProfilingTargetTypeOffCPU, EBPFProfilingTargetTypeNetwork:
		return true
	}
	return false
}

func (e EBPFProfilingTargetType) String() string {
	return string(e)
}

func (e *EBPFProfilingTargetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EBPFProfilingTargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EBPFProfilingTargetType", str)
	}
	return nil
}

func (e EBPFProfilingTargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EBPFProfilingTriggerType string

const (
	EBPFProfilingTriggerTypeFixedTime           EBPFProfilingTriggerType = "FIXED_TIME"
	EBPFProfilingTriggerTypeContinuousProfiling EBPFProfilingTriggerType = "CONTINUOUS_PROFILING"
)

var AllEBPFProfilingTriggerType = []EBPFProfilingTriggerType{
	EBPFProfilingTriggerTypeFixedTime,
	EBPFProfilingTriggerTypeContinuousProfiling,
}

func (e EBPFProfilingTriggerType) IsValid() bool {
	switch e {
	case EBPFProfilingTriggerTypeFixedTime, EBPFProfilingTriggerTypeContinuousProfiling:
		return true
	}
	return false
}

func (e EBPFProfilingTriggerType) String() string {
	return string(e)
}

func (e *EBPFProfilingTriggerType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EBPFProfilingTriggerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EBPFProfilingTriggerType", str)
	}
	return nil
}

func (e EBPFProfilingTriggerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ErrorCategory string

const (
	ErrorCategoryAll      ErrorCategory = "ALL"
	ErrorCategoryAjax     ErrorCategory = "AJAX"
	ErrorCategoryResource ErrorCategory = "RESOURCE"
	ErrorCategoryVue      ErrorCategory = "VUE"
	ErrorCategoryPromise  ErrorCategory = "PROMISE"
	ErrorCategoryJs       ErrorCategory = "JS"
	ErrorCategoryUnknown  ErrorCategory = "UNKNOWN"
)

var AllErrorCategory = []ErrorCategory{
	ErrorCategoryAll,
	ErrorCategoryAjax,
	ErrorCategoryResource,
	ErrorCategoryVue,
	ErrorCategoryPromise,
	ErrorCategoryJs,
	ErrorCategoryUnknown,
}

func (e ErrorCategory) IsValid() bool {
	switch e {
	case ErrorCategoryAll, ErrorCategoryAjax, ErrorCategoryResource, ErrorCategoryVue, ErrorCategoryPromise, ErrorCategoryJs, ErrorCategoryUnknown:
		return true
	}
	return false
}

func (e ErrorCategory) String() string {
	return string(e)
}

func (e *ErrorCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorCategory", str)
	}
	return nil
}

func (e ErrorCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventType string

const (
	EventTypeNormal EventType = "Normal"
	EventTypeError  EventType = "Error"
)

var AllEventType = []EventType{
	EventTypeNormal,
	EventTypeError,
}

func (e EventType) IsValid() bool {
	switch e {
	case EventTypeNormal, EventTypeError:
		return true
	}
	return false
}

func (e EventType) String() string {
	return string(e)
}

func (e *EventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventType", str)
	}
	return nil
}

func (e EventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ExpressionResultType string

const (
	ExpressionResultTypeUnknown          ExpressionResultType = "UNKNOWN"
	ExpressionResultTypeSingleValue      ExpressionResultType = "SINGLE_VALUE"
	ExpressionResultTypeTimeSeriesValues ExpressionResultType = "TIME_SERIES_VALUES"
	ExpressionResultTypeSortedList       ExpressionResultType = "SORTED_LIST"
	ExpressionResultTypeRecordList       ExpressionResultType = "RECORD_LIST"
)

var AllExpressionResultType = []ExpressionResultType{
	ExpressionResultTypeUnknown,
	ExpressionResultTypeSingleValue,
	ExpressionResultTypeTimeSeriesValues,
	ExpressionResultTypeSortedList,
	ExpressionResultTypeRecordList,
}

func (e ExpressionResultType) IsValid() bool {
	switch e {
	case ExpressionResultTypeUnknown, ExpressionResultTypeSingleValue, ExpressionResultTypeTimeSeriesValues, ExpressionResultTypeSortedList, ExpressionResultTypeRecordList:
		return true
	}
	return false
}

func (e ExpressionResultType) String() string {
	return string(e)
}

func (e *ExpressionResultType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExpressionResultType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExpressionResultType", str)
	}
	return nil
}

func (e ExpressionResultType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Language string

const (
	LanguageUnknown Language = "UNKNOWN"
	LanguageJava    Language = "JAVA"
	LanguageDotnet  Language = "DOTNET"
	LanguageNodejs  Language = "NODEJS"
	LanguagePython  Language = "PYTHON"
	LanguageRuby    Language = "RUBY"
	LanguageGo      Language = "GO"
	LanguageLua     Language = "LUA"
	LanguagePhp     Language = "PHP"
)

var AllLanguage = []Language{
	LanguageUnknown,
	LanguageJava,
	LanguageDotnet,
	LanguageNodejs,
	LanguagePython,
	LanguageRuby,
	LanguageGo,
	LanguageLua,
	LanguagePhp,
}

func (e Language) IsValid() bool {
	switch e {
	case LanguageUnknown, LanguageJava, LanguageDotnet, LanguageNodejs, LanguagePython, LanguageRuby, LanguageGo, LanguageLua, LanguagePhp:
		return true
	}
	return false
}

func (e Language) String() string {
	return string(e)
}

func (e *Language) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Language(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Language", str)
	}
	return nil
}

func (e Language) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MetricsType string

const (
	MetricsTypeUnknown       MetricsType = "UNKNOWN"
	MetricsTypeRegularValue  MetricsType = "REGULAR_VALUE"
	MetricsTypeLabeledValue  MetricsType = "LABELED_VALUE"
	MetricsTypeHeatmap       MetricsType = "HEATMAP"
	MetricsTypeSampledRecord MetricsType = "SAMPLED_RECORD"
)

var AllMetricsType = []MetricsType{
	MetricsTypeUnknown,
	MetricsTypeRegularValue,
	MetricsTypeLabeledValue,
	MetricsTypeHeatmap,
	MetricsTypeSampledRecord,
}

func (e MetricsType) IsValid() bool {
	switch e {
	case MetricsTypeUnknown, MetricsTypeRegularValue, MetricsTypeLabeledValue, MetricsTypeHeatmap, MetricsTypeSampledRecord:
		return true
	}
	return false
}

func (e MetricsType) String() string {
	return string(e)
}

func (e *MetricsType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetricsType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetricsType", str)
	}
	return nil
}

func (e MetricsType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Order string

const (
	OrderAsc Order = "ASC"
	OrderDes Order = "DES"
)

var AllOrder = []Order{
	OrderAsc,
	OrderDes,
}

func (e Order) IsValid() bool {
	switch e {
	case OrderAsc, OrderDes:
		return true
	}
	return false
}

func (e Order) String() string {
	return string(e)
}

func (e *Order) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Order(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Order", str)
	}
	return nil
}

func (e Order) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProfileTaskLogOperationType string

const (
	ProfileTaskLogOperationTypeNotified          ProfileTaskLogOperationType = "NOTIFIED"
	ProfileTaskLogOperationTypeExecutionFinished ProfileTaskLogOperationType = "EXECUTION_FINISHED"
)

var AllProfileTaskLogOperationType = []ProfileTaskLogOperationType{
	ProfileTaskLogOperationTypeNotified,
	ProfileTaskLogOperationTypeExecutionFinished,
}

func (e ProfileTaskLogOperationType) IsValid() bool {
	switch e {
	case ProfileTaskLogOperationTypeNotified, ProfileTaskLogOperationTypeExecutionFinished:
		return true
	}
	return false
}

func (e ProfileTaskLogOperationType) String() string {
	return string(e)
}

func (e *ProfileTaskLogOperationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProfileTaskLogOperationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProfileTaskLogOperationType", str)
	}
	return nil
}

func (e ProfileTaskLogOperationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type QueryOrder string

const (
	QueryOrderByStartTime QueryOrder = "BY_START_TIME"
	QueryOrderByDuration  QueryOrder = "BY_DURATION"
)

var AllQueryOrder = []QueryOrder{
	QueryOrderByStartTime,
	QueryOrderByDuration,
}

func (e QueryOrder) IsValid() bool {
	switch e {
	case QueryOrderByStartTime, QueryOrderByDuration:
		return true
	}
	return false
}

func (e QueryOrder) String() string {
	return string(e)
}

func (e *QueryOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = QueryOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid QueryOrder", str)
	}
	return nil
}

func (e QueryOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RefType string

const (
	RefTypeCrossProcess RefType = "CROSS_PROCESS"
	RefTypeCrossThread  RefType = "CROSS_THREAD"
)

var AllRefType = []RefType{
	RefTypeCrossProcess,
	RefTypeCrossThread,
}

func (e RefType) IsValid() bool {
	switch e {
	case RefTypeCrossProcess, RefTypeCrossThread:
		return true
	}
	return false
}

func (e RefType) String() string {
	return string(e)
}

func (e *RefType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RefType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RefType", str)
	}
	return nil
}

func (e RefType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Scope string

const (
	ScopeAll                     Scope = "All"
	ScopeService                 Scope = "Service"
	ScopeServiceInstance         Scope = "ServiceInstance"
	ScopeEndpoint                Scope = "Endpoint"
	ScopeProcess                 Scope = "Process"
	ScopeServiceRelation         Scope = "ServiceRelation"
	ScopeServiceInstanceRelation Scope = "ServiceInstanceRelation"
	ScopeEndpointRelation        Scope = "EndpointRelation"
	ScopeProcessRelation         Scope = "ProcessRelation"
)

var AllScope = []Scope{
	ScopeAll,
	ScopeService,
	ScopeServiceInstance,
	ScopeEndpoint,
	ScopeProcess,
	ScopeServiceRelation,
	ScopeServiceInstanceRelation,
	ScopeEndpointRelation,
	ScopeProcessRelation,
}

func (e Scope) IsValid() bool {
	switch e {
	case ScopeAll, ScopeService, ScopeServiceInstance, ScopeEndpoint, ScopeProcess, ScopeServiceRelation, ScopeServiceInstanceRelation, ScopeEndpointRelation, ScopeProcessRelation:
		return true
	}
	return false
}

func (e Scope) String() string {
	return string(e)
}

func (e *Scope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Scope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Scope", str)
	}
	return nil
}

func (e Scope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Step string

const (
	StepDay    Step = "DAY"
	StepHour   Step = "HOUR"
	StepMinute Step = "MINUTE"
	StepSecond Step = "SECOND"
)

var AllStep = []Step{
	StepDay,
	StepHour,
	StepMinute,
	StepSecond,
}

func (e Step) IsValid() bool {
	switch e {
	case StepDay, StepHour, StepMinute, StepSecond:
		return true
	}
	return false
}

func (e Step) String() string {
	return string(e)
}

func (e *Step) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Step(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Step", str)
	}
	return nil
}

func (e Step) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TraceState string

const (
	TraceStateAll     TraceState = "ALL"
	TraceStateSuccess TraceState = "SUCCESS"
	TraceStateError   TraceState = "ERROR"
)

var AllTraceState = []TraceState{
	TraceStateAll,
	TraceStateSuccess,
	TraceStateError,
}

func (e TraceState) IsValid() bool {
	switch e {
	case TraceStateAll, TraceStateSuccess, TraceStateError:
		return true
	}
	return false
}

func (e TraceState) String() string {
	return string(e)
}

func (e *TraceState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TraceState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TraceState", str)
	}
	return nil
}

func (e TraceState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
