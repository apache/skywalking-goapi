// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package query

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

type AlarmMessage struct {
	StartTime int64          `json:"startTime"`
	Scope     *Scope         `json:"scope,omitempty"`
	ID        string         `json:"id"`
	Name      string         `json:"name"`
	Message   string         `json:"message"`
	Events    []*Event       `json:"events"`
	Tags      []*KeyValue    `json:"tags"`
	Snapshot  *AlarmSnapshot `json:"snapshot"`
}

type AlarmSnapshot struct {
	Expression string       `json:"expression"`
	Metrics    []*MQEMetric `json:"metrics"`
}

type AlarmTag struct {
	Key   string  `json:"key"`
	Value *string `json:"value,omitempty"`
}

type Alarms struct {
	Msgs []*AlarmMessage `json:"msgs"`
}

type AsyncProfilerAnalyzation struct {
	Tree *AsyncProfilerStackTree `json:"tree,omitempty"`
}

type AsyncProfilerAnalyzationRequest struct {
	TaskID      string       `json:"taskId"`
	InstanceIds []string     `json:"instanceIds"`
	EventType   JFREventType `json:"eventType"`
}

type AsyncProfilerStackElement struct {
	ID            string `json:"id"`
	ParentID      string `json:"parentId"`
	CodeSignature string `json:"codeSignature"`
	Total         int64  `json:"total"`
	Self          int64  `json:"self"`
}

type AsyncProfilerStackTree struct {
	Type     JFREventType                 `json:"type"`
	Elements []*AsyncProfilerStackElement `json:"elements,omitempty"`
}

type AsyncProfilerTask struct {
	ID                 string                   `json:"id"`
	ServiceID          string                   `json:"serviceId"`
	ServiceInstanceIds []string                 `json:"serviceInstanceIds"`
	CreateTime         int64                    `json:"createTime"`
	Events             []AsyncProfilerEventType `json:"events"`
	Duration           int                      `json:"duration"`
	ExecArgs           *string                  `json:"execArgs,omitempty"`
}

type AsyncProfilerTaskCreationRequest struct {
	ServiceID          string                   `json:"serviceId"`
	ServiceInstanceIds []string                 `json:"serviceInstanceIds"`
	Duration           int                      `json:"duration"`
	Events             []AsyncProfilerEventType `json:"events"`
	ExecArgs           *string                  `json:"execArgs,omitempty"`
}

type AsyncProfilerTaskCreationResult struct {
	Code        AsyncProfilerTaskCreationType `json:"code"`
	ErrorReason *string                       `json:"errorReason,omitempty"`
	ID          *string                       `json:"id,omitempty"`
}

type AsyncProfilerTaskListRequest struct {
	ServiceID     string    `json:"serviceId"`
	QueryDuration *Duration `json:"queryDuration,omitempty"`
	Limit         *int      `json:"limit,omitempty"`
}

type AsyncProfilerTaskListResult struct {
	ErrorReason *string              `json:"errorReason,omitempty"`
	Tasks       []*AsyncProfilerTask `json:"tasks,omitempty"`
}

type AsyncProfilerTaskLog struct {
	ID            string                            `json:"id"`
	InstanceID    string                            `json:"instanceId"`
	InstanceName  string                            `json:"instanceName"`
	OperationType AsyncProfilerTaskLogOperationType `json:"operationType"`
	OperationTime int64                             `json:"operationTime"`
}

type AsyncProfilerTaskProgress struct {
	Logs               []*AsyncProfilerTaskLog `json:"logs,omitempty"`
	ErrorInstanceIds   []*string               `json:"errorInstanceIds,omitempty"`
	SuccessInstanceIds []*string               `json:"successInstanceIds,omitempty"`
}

type Attribute struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type BasicTrace struct {
	SegmentID     string   `json:"segmentId"`
	EndpointNames []string `json:"endpointNames"`
	Duration      int      `json:"duration"`
	Start         string   `json:"start"`
	IsError       *bool    `json:"isError,omitempty"`
	TraceIds      []string `json:"traceIds"`
}

type BatchMetricConditions struct {
	Name string   `json:"name"`
	Ids  []string `json:"ids"`
}

type BrowserErrorLog struct {
	Service            string        `json:"service"`
	ServiceVersion     string        `json:"serviceVersion"`
	Time               int64         `json:"time"`
	PagePath           string        `json:"pagePath"`
	Category           ErrorCategory `json:"category"`
	Grade              *string       `json:"grade,omitempty"`
	Message            *string       `json:"message,omitempty"`
	Line               *int          `json:"line,omitempty"`
	Col                *int          `json:"col,omitempty"`
	Stack              *string       `json:"stack,omitempty"`
	ErrorURL           *string       `json:"errorUrl,omitempty"`
	FirstReportedError bool          `json:"firstReportedError"`
}

type BrowserErrorLogQueryCondition struct {
	ServiceID        *string        `json:"serviceId,omitempty"`
	ServiceVersionID *string        `json:"serviceVersionId,omitempty"`
	PagePathID       *string        `json:"pagePathId,omitempty"`
	Category         *ErrorCategory `json:"category,omitempty"`
	QueryDuration    *Duration      `json:"queryDuration,omitempty"`
	Paging           *Pagination    `json:"paging"`
}

type BrowserErrorLogs struct {
	Logs []*BrowserErrorLog `json:"logs"`
}

type Bucket struct {
	Min string `json:"min"`
	Max string `json:"max"`
}

type Call struct {
	Source           string        `json:"source"`
	SourceComponents []string      `json:"sourceComponents"`
	Target           string        `json:"target"`
	TargetComponents []string      `json:"targetComponents"`
	ID               string        `json:"id"`
	DetectPoints     []DetectPoint `json:"detectPoints"`
}

type ContinuousProfilingMonitoringInstance struct {
	ID                   string                                  `json:"id"`
	Name                 string                                  `json:"name"`
	Attributes           []*Attribute                            `json:"attributes"`
	TriggeredCount       int                                     `json:"triggeredCount"`
	LastTriggerTimestamp *int64                                  `json:"lastTriggerTimestamp,omitempty"`
	Processes            []*ContinuousProfilingMonitoringProcess `json:"processes"`
}

type ContinuousProfilingMonitoringProcess struct {
	ID                   string   `json:"id"`
	Name                 string   `json:"name"`
	DetectType           string   `json:"detectType"`
	Labels               []string `json:"labels"`
	TriggeredCount       int      `json:"triggeredCount"`
	LastTriggerTimestamp *int64   `json:"lastTriggerTimestamp,omitempty"`
}

type ContinuousProfilingPolicyCreation struct {
	ServiceID string                                     `json:"serviceId"`
	Targets   []*ContinuousProfilingPolicyTargetCreation `json:"targets"`
}

type ContinuousProfilingPolicyItem struct {
	Type      ContinuousProfilingMonitorType `json:"type"`
	Threshold string                         `json:"threshold"`
	Period    int                            `json:"period"`
	Count     int                            `json:"count"`
	URIList   []string                       `json:"uriList,omitempty"`
	URIRegex  *string                        `json:"uriRegex,omitempty"`
}

type ContinuousProfilingPolicyItemCreation struct {
	Type      ContinuousProfilingMonitorType `json:"type"`
	Threshold string                         `json:"threshold"`
	Period    int                            `json:"period"`
	Count     int                            `json:"count"`
	URIList   []string                       `json:"uriList,omitempty"`
	URIRegex  *string                        `json:"uriRegex,omitempty"`
}

type ContinuousProfilingPolicyTarget struct {
	Type                 ContinuousProfilingTargetType    `json:"type"`
	CheckItems           []*ContinuousProfilingPolicyItem `json:"checkItems"`
	TriggeredCount       int                              `json:"triggeredCount"`
	LastTriggerTimestamp *int64                           `json:"lastTriggerTimestamp,omitempty"`
}

type ContinuousProfilingPolicyTargetCreation struct {
	TargetType ContinuousProfilingTargetType            `json:"targetType"`
	CheckItems []*ContinuousProfilingPolicyItemCreation `json:"checkItems"`
}

type ContinuousProfilingSetResult struct {
	Status      bool    `json:"status"`
	ErrorReason *string `json:"errorReason,omitempty"`
}

type ContinuousProfilingSingleValueCause struct {
	Threshold int64 `json:"threshold"`
	Current   int64 `json:"current"`
}

type ContinuousProfilingTriggeredCause struct {
	Type        ContinuousProfilingMonitorType       `json:"type"`
	SingleValue *ContinuousProfilingSingleValueCause `json:"singleValue,omitempty"`
	URI         *ContinuousProfilingURICause         `json:"uri,omitempty"`
	Message     string                               `json:"message"`
}

type ContinuousProfilingURICause struct {
	URIRegex  *string `json:"uriRegex,omitempty"`
	URIPath   *string `json:"uriPath,omitempty"`
	Threshold int64   `json:"threshold"`
	Current   int64   `json:"current"`
}

type DashboardConfiguration struct {
	ID            string `json:"id"`
	Configuration string `json:"configuration"`
}

type DashboardSetting struct {
	ID            string `json:"id"`
	Configuration string `json:"configuration"`
}

type Database struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	Type string `json:"type"`
}

type DebuggingSpan struct {
	SpanID       int     `json:"spanId"`
	ParentSpanID int     `json:"parentSpanId"`
	Operation    string  `json:"operation"`
	StartTime    int64   `json:"startTime"`
	EndTime      int64   `json:"endTime"`
	Duration     int64   `json:"duration"`
	Msg          *string `json:"msg,omitempty"`
	Error        *string `json:"error,omitempty"`
}

type DebuggingTrace struct {
	TraceID   string           `json:"traceId"`
	Condition string           `json:"condition"`
	StartTime int64            `json:"startTime"`
	EndTime   int64            `json:"endTime"`
	Duration  int64            `json:"duration"`
	Spans     []*DebuggingSpan `json:"spans"`
}

type Duration struct {
	Start     string `json:"start"`
	End       string `json:"end"`
	Step      Step   `json:"step"`
	ColdStage *bool  `json:"coldStage,omitempty"`
}

type EBPFNetworkDataCollectingSettings struct {
	RequireCompleteRequest  bool `json:"requireCompleteRequest"`
	MaxRequestSize          *int `json:"maxRequestSize,omitempty"`
	RequireCompleteResponse bool `json:"requireCompleteResponse"`
	MaxResponseSize         *int `json:"maxResponseSize,omitempty"`
}

type EBPFNetworkKeepProfilingResult struct {
	Status      bool    `json:"status"`
	ErrorReason *string `json:"errorReason,omitempty"`
}

type EBPFNetworkSamplingRule struct {
	URIRegex    *string                            `json:"uriRegex,omitempty"`
	MinDuration *int                               `json:"minDuration,omitempty"`
	When4xx     bool                               `json:"when4xx"`
	When5xx     bool                               `json:"when5xx"`
	Settings    *EBPFNetworkDataCollectingSettings `json:"settings"`
}

type EBPFProfilingAnalyzation struct {
	Tip   *string              `json:"tip,omitempty"`
	Trees []*EBPFProfilingTree `json:"trees"`
}

type EBPFProfilingAnalyzeTimeRange struct {
	Start int64 `json:"start"`
	End   int64 `json:"end"`
}

type EBPFProfilingNetworkTaskRequest struct {
	InstanceID string                     `json:"instanceId"`
	Samplings  []*EBPFNetworkSamplingRule `json:"samplings,omitempty"`
}

type EBPFProfilingSchedule struct {
	ScheduleID string   `json:"scheduleId"`
	TaskID     string   `json:"taskId"`
	Process    *Process `json:"process"`
	StartTime  int64    `json:"startTime"`
	EndTime    int64    `json:"endTime"`
}

type EBPFProfilingStackElement struct {
	ID        string                 `json:"id"`
	ParentID  string                 `json:"parentId"`
	Symbol    string                 `json:"symbol"`
	StackType EBPFProfilingStackType `json:"stackType"`
	DumpCount int64                  `json:"dumpCount"`
}

type EBPFProfilingTask struct {
	TaskID                    string                               `json:"taskId"`
	ServiceID                 string                               `json:"serviceId"`
	ServiceName               string                               `json:"serviceName"`
	ServiceInstanceID         *string                              `json:"serviceInstanceId,omitempty"`
	ServiceInstanceName       *string                              `json:"serviceInstanceName,omitempty"`
	ProcessLabels             []string                             `json:"processLabels"`
	ProcessID                 *string                              `json:"processId,omitempty"`
	ProcessName               *string                              `json:"processName,omitempty"`
	TaskStartTime             int64                                `json:"taskStartTime"`
	TriggerType               EBPFProfilingTriggerType             `json:"triggerType"`
	FixedTriggerDuration      *int64                               `json:"fixedTriggerDuration,omitempty"`
	ContinuousProfilingCauses []*ContinuousProfilingTriggeredCause `json:"continuousProfilingCauses,omitempty"`
	TargetType                EBPFProfilingTargetType              `json:"targetType"`
	CreateTime                int64                                `json:"createTime"`
}

type EBPFProfilingTaskCreationResult struct {
	Status      bool    `json:"status"`
	ErrorReason *string `json:"errorReason,omitempty"`
	ID          *string `json:"id,omitempty"`
}

type EBPFProfilingTaskFixedTimeCreationRequest struct {
	ServiceID     string                  `json:"serviceId"`
	ProcessLabels []string                `json:"processLabels"`
	StartTime     int64                   `json:"startTime"`
	Duration      int                     `json:"duration"`
	TargetType    EBPFProfilingTargetType `json:"targetType"`
}

type EBPFProfilingTaskPrepare struct {
	CouldProfiling bool     `json:"couldProfiling"`
	ProcessLabels  []string `json:"processLabels"`
}

type EBPFProfilingTree struct {
	Elements []*EBPFProfilingStackElement `json:"elements"`
}

type Endpoint struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type EndpointCondition struct {
	ServiceName  string  `json:"serviceName"`
	EndpointName string  `json:"endpointName"`
	Layer        *string `json:"layer,omitempty"`
}

type EndpointInfo struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	ServiceID   string `json:"serviceId"`
	ServiceName string `json:"serviceName"`
}

type EndpointNode struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	ServiceID   string  `json:"serviceId"`
	ServiceName string  `json:"serviceName"`
	Type        *string `json:"type,omitempty"`
	IsReal      bool    `json:"isReal"`
}

type EndpointTopology struct {
	Nodes          []*EndpointNode `json:"nodes"`
	Calls          []*Call         `json:"calls"`
	DebuggingTrace *DebuggingTrace `json:"debuggingTrace,omitempty"`
}

type Entity struct {
	Scope                   *Scope  `json:"scope,omitempty"`
	ServiceName             *string `json:"serviceName,omitempty"`
	Normal                  *bool   `json:"normal,omitempty"`
	ServiceInstanceName     *string `json:"serviceInstanceName,omitempty"`
	EndpointName            *string `json:"endpointName,omitempty"`
	ProcessName             *string `json:"processName,omitempty"`
	DestServiceName         *string `json:"destServiceName,omitempty"`
	DestNormal              *bool   `json:"destNormal,omitempty"`
	DestServiceInstanceName *string `json:"destServiceInstanceName,omitempty"`
	DestEndpointName        *string `json:"destEndpointName,omitempty"`
	DestProcessName         *string `json:"destProcessName,omitempty"`
}

type Event struct {
	UUID       string      `json:"uuid"`
	Source     *Source     `json:"source"`
	Name       string      `json:"name"`
	Type       EventType   `json:"type"`
	Message    *string     `json:"message,omitempty"`
	Parameters []*KeyValue `json:"parameters,omitempty"`
	StartTime  int64       `json:"startTime"`
	EndTime    *int64      `json:"endTime,omitempty"`
	Layer      string      `json:"layer"`
}

type EventQueryCondition struct {
	UUID   *string      `json:"uuid,omitempty"`
	Source *SourceInput `json:"source,omitempty"`
	Name   *string      `json:"name,omitempty"`
	Type   *EventType   `json:"type,omitempty"`
	Time   *Duration    `json:"time,omitempty"`
	Order  *Order       `json:"order,omitempty"`
	Layer  *string      `json:"layer,omitempty"`
	Paging *Pagination  `json:"paging"`
}

type Events struct {
	Events []*Event `json:"events"`
}

type ExpressionResult struct {
	Type           ExpressionResultType `json:"type"`
	Results        []*MQEValues         `json:"results"`
	Error          *string              `json:"error,omitempty"`
	DebuggingTrace *DebuggingTrace      `json:"debuggingTrace,omitempty"`
}

type HealthStatus struct {
	Score   int     `json:"score"`
	Details *string `json:"details,omitempty"`
}

type HeatMap struct {
	Values  []*HeatMapColumn `json:"values"`
	Buckets []*Bucket        `json:"buckets"`
}

type HeatMapColumn struct {
	ID     string  `json:"id"`
	Values []int64 `json:"values"`
}

type HierarchyInstanceRelation struct {
	UpperInstance *HierarchyRelatedInstance `json:"upperInstance"`
	LowerInstance *HierarchyRelatedInstance `json:"lowerInstance"`
}

type HierarchyRelatedInstance struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	ServiceID   string `json:"serviceId"`
	ServiceName string `json:"serviceName"`
	Layer       string `json:"layer"`
	Normal      bool   `json:"normal"`
}

type HierarchyRelatedService struct {
	ID     string `json:"id"`
	Name   string `json:"name"`
	Layer  string `json:"layer"`
	Normal bool   `json:"normal"`
}

type HierarchyServiceRelation struct {
	UpperService *HierarchyRelatedService `json:"upperService"`
	LowerService *HierarchyRelatedService `json:"lowerService"`
}

type InstanceCondition struct {
	ServiceName  string  `json:"serviceName"`
	InstanceName string  `json:"instanceName"`
	Layer        *string `json:"layer,omitempty"`
}

type InstanceHierarchy struct {
	Relations []*HierarchyInstanceRelation `json:"relations"`
}

type Instant struct {
	Seconds int64 `json:"seconds"`
	Nanos   int   `json:"nanos"`
}

type IntValues struct {
	Values []*KVInt `json:"values"`
}

type KVInt struct {
	ID           string `json:"id"`
	Value        int64  `json:"value"`
	IsEmptyValue bool   `json:"isEmptyValue"`
}

type KeyNumericValue struct {
	Key   string `json:"key"`
	Value int64  `json:"value"`
}

type KeyValue struct {
	Key   string  `json:"key"`
	Value *string `json:"value,omitempty"`
}

type LayerLevel struct {
	Layer string `json:"layer"`
	Level int    `json:"level"`
}

type Log struct {
	ServiceName         *string     `json:"serviceName,omitempty"`
	ServiceID           *string     `json:"serviceId,omitempty"`
	ServiceInstanceName *string     `json:"serviceInstanceName,omitempty"`
	ServiceInstanceID   *string     `json:"serviceInstanceId,omitempty"`
	EndpointName        *string     `json:"endpointName,omitempty"`
	EndpointID          *string     `json:"endpointId,omitempty"`
	TraceID             *string     `json:"traceId,omitempty"`
	Timestamp           int64       `json:"timestamp"`
	ContentType         ContentType `json:"contentType"`
	Content             *string     `json:"content,omitempty"`
	Tags                []*KeyValue `json:"tags,omitempty"`
}

type LogEntity struct {
	Time int64       `json:"time"`
	Data []*KeyValue `json:"data,omitempty"`
}

type LogQueryCondition struct {
	ServiceID                  *string              `json:"serviceId,omitempty"`
	ServiceInstanceID          *string              `json:"serviceInstanceId,omitempty"`
	EndpointID                 *string              `json:"endpointId,omitempty"`
	RelatedTrace               *TraceScopeCondition `json:"relatedTrace,omitempty"`
	QueryDuration              *Duration            `json:"queryDuration,omitempty"`
	Paging                     *Pagination          `json:"paging"`
	Tags                       []*LogTag            `json:"tags,omitempty"`
	KeywordsOfContent          []string             `json:"keywordsOfContent,omitempty"`
	ExcludingKeywordsOfContent []string             `json:"excludingKeywordsOfContent,omitempty"`
	QueryOrder                 *Order               `json:"queryOrder,omitempty"`
}

type LogQueryConditionByName struct {
	Service                    *ServiceCondition    `json:"service,omitempty"`
	Instance                   *InstanceCondition   `json:"instance,omitempty"`
	Endpoint                   *EndpointCondition   `json:"endpoint,omitempty"`
	RelatedTrace               *TraceScopeCondition `json:"relatedTrace,omitempty"`
	QueryDuration              *Duration            `json:"queryDuration,omitempty"`
	Paging                     *Pagination          `json:"paging"`
	Tags                       []*LogTag            `json:"tags,omitempty"`
	KeywordsOfContent          []string             `json:"keywordsOfContent,omitempty"`
	ExcludingKeywordsOfContent []string             `json:"excludingKeywordsOfContent,omitempty"`
	QueryOrder                 *Order               `json:"queryOrder,omitempty"`
}

type LogTag struct {
	Key   string  `json:"key"`
	Value *string `json:"value,omitempty"`
}

type LogTestMetrics struct {
	Name      string      `json:"name"`
	Tags      []*KeyValue `json:"tags,omitempty"`
	Value     int64       `json:"value"`
	Timestamp int64       `json:"timestamp"`
}

type LogTestRequest struct {
	Log string `json:"log"`
	Dsl string `json:"dsl"`
}

type LogTestResponse struct {
	Log     *Log              `json:"log,omitempty"`
	Metrics []*LogTestMetrics `json:"metrics,omitempty"`
}

type Logs struct {
	ErrorReason    *string         `json:"errorReason,omitempty"`
	Logs           []*Log          `json:"logs"`
	DebuggingTrace *DebuggingTrace `json:"debuggingTrace,omitempty"`
}

type MQEMetric struct {
	Name    string       `json:"name"`
	Results []*MQEValues `json:"results"`
}

type MQEValue struct {
	ID      *string `json:"id,omitempty"`
	Owner   *Owner  `json:"owner,omitempty"`
	Value   *string `json:"value,omitempty"`
	TraceID *string `json:"traceID,omitempty"`
}

type MQEValues struct {
	Metric *Metadata   `json:"metric"`
	Values []*MQEValue `json:"values"`
}

type MenuItem struct {
	Title        string      `json:"title"`
	Icon         *string     `json:"icon,omitempty"`
	Layer        string      `json:"layer"`
	Activate     bool        `json:"activate"`
	SubItems     []*MenuItem `json:"subItems"`
	Description  *string     `json:"description,omitempty"`
	DocumentLink *string     `json:"documentLink,omitempty"`
	I18nKey      *string     `json:"i18nKey,omitempty"`
}

type Metadata struct {
	Labels []*KeyValue `json:"labels"`
}

type MetricCondition struct {
	Name string  `json:"name"`
	ID   *string `json:"id,omitempty"`
}

type MetricDefinition struct {
	Name    string      `json:"name"`
	Type    MetricsType `json:"type"`
	Catalog *string     `json:"catalog,omitempty"`
}

type MetricsCondition struct {
	Name   string  `json:"name"`
	Entity *Entity `json:"entity"`
}

type MetricsTTL struct {
	Minute     int `json:"minute"`
	Hour       int `json:"hour"`
	Day        int `json:"day"`
	ColdMinute int `json:"coldMinute"`
	ColdHour   int `json:"coldHour"`
	ColdDay    int `json:"coldDay"`
}

type MetricsValues struct {
	Label  *string    `json:"label,omitempty"`
	Values *IntValues `json:"values,omitempty"`
}

type Mutation struct {
}

type NewDashboardSetting struct {
	Configuration string `json:"configuration"`
}

type Node struct {
	ID     string   `json:"id"`
	Name   string   `json:"name"`
	Type   *string  `json:"type,omitempty"`
	IsReal bool     `json:"isReal"`
	Layers []string `json:"layers"`
}

type NullableValue struct {
	Value        int64 `json:"value"`
	IsEmptyValue bool  `json:"isEmptyValue"`
}

type OndemandContainergQueryCondition struct {
	ServiceInstanceID *string `json:"serviceInstanceId,omitempty"`
}

type OndemandLogQueryCondition struct {
	ServiceInstanceID          *string   `json:"serviceInstanceId,omitempty"`
	Container                  string    `json:"container"`
	Duration                   *Duration `json:"duration,omitempty"`
	KeywordsOfContent          []string  `json:"keywordsOfContent,omitempty"`
	ExcludingKeywordsOfContent []string  `json:"excludingKeywordsOfContent,omitempty"`
}

type Owner struct {
	Scope               *Scope  `json:"scope,omitempty"`
	ServiceID           *string `json:"serviceID,omitempty"`
	ServiceName         *string `json:"serviceName,omitempty"`
	Normal              *bool   `json:"normal,omitempty"`
	ServiceInstanceID   *string `json:"serviceInstanceID,omitempty"`
	ServiceInstanceName *string `json:"serviceInstanceName,omitempty"`
	EndpointID          *string `json:"endpointID,omitempty"`
	EndpointName        *string `json:"endpointName,omitempty"`
}

type Pagination struct {
	PageNum  *int `json:"pageNum,omitempty"`
	PageSize int  `json:"pageSize"`
}

type PodContainers struct {
	ErrorReason *string  `json:"errorReason,omitempty"`
	Containers  []string `json:"containers"`
}

type PprofAnalyzation struct {
	Tree *PprofStackTree `json:"tree,omitempty"`
}

type PprofAnalyzationRequest struct {
	TaskID      string   `json:"taskId"`
	InstanceIds []string `json:"instanceIds"`
}

type PprofStackElement struct {
	ID            string `json:"id"`
	ParentID      string `json:"parentId"`
	CodeSignature string `json:"codeSignature"`
	Total         int64  `json:"total"`
	Self          int64  `json:"self"`
}

type PprofStackTree struct {
	Elements []*PprofStackElement `json:"elements,omitempty"`
}

type PprofTask struct {
	ID                 string         `json:"id"`
	ServiceID          string         `json:"serviceId"`
	ServiceInstanceIds []string       `json:"serviceInstanceIds"`
	CreateTime         int64          `json:"createTime"`
	Events             PprofEventType `json:"events"`
	Duration           *int           `json:"duration,omitempty"`
	DumpPeriod         *int           `json:"dumpPeriod,omitempty"`
}

type PprofTaskCreationRequest struct {
	ServiceID          string         `json:"serviceId"`
	ServiceInstanceIds []string       `json:"serviceInstanceIds"`
	Duration           *int           `json:"duration,omitempty"`
	Events             PprofEventType `json:"events"`
	DumpPeriod         *int           `json:"dumpPeriod,omitempty"`
}

type PprofTaskCreationResult struct {
	Code        PprofTaskCreationType `json:"code"`
	ErrorReason *string               `json:"errorReason,omitempty"`
	ID          *string               `json:"id,omitempty"`
}

type PprofTaskListRequest struct {
	ServiceID     string    `json:"serviceId"`
	QueryDuration *Duration `json:"queryDuration,omitempty"`
	Limit         *int      `json:"limit,omitempty"`
}

type PprofTaskListResult struct {
	ErrorReason *string      `json:"errorReason,omitempty"`
	Tasks       []*PprofTask `json:"tasks,omitempty"`
}

type PprofTaskLog struct {
	ID            string                    `json:"id"`
	InstanceID    string                    `json:"instanceId"`
	InstanceName  string                    `json:"instanceName"`
	OperationType PprofTaskLogOperationType `json:"operationType"`
	OperationTime int64                     `json:"operationTime"`
}

type PprofTaskProgress struct {
	Logs               []*PprofTaskLog `json:"logs,omitempty"`
	ErrorInstanceIds   []*string       `json:"errorInstanceIds,omitempty"`
	SuccessInstanceIds []*string       `json:"successInstanceIds,omitempty"`
}

type Process struct {
	ID           string       `json:"id"`
	Name         string       `json:"name"`
	ServiceID    string       `json:"serviceId"`
	ServiceName  string       `json:"serviceName"`
	InstanceID   string       `json:"instanceId"`
	InstanceName string       `json:"instanceName"`
	AgentID      string       `json:"agentId"`
	DetectType   string       `json:"detectType"`
	Attributes   []*Attribute `json:"attributes"`
	Labels       []string     `json:"labels"`
}

type ProcessNode struct {
	ID                  string `json:"id"`
	ServiceID           string `json:"serviceId"`
	ServiceName         string `json:"serviceName"`
	ServiceInstanceID   string `json:"serviceInstanceId"`
	ServiceInstanceName string `json:"serviceInstanceName"`
	Name                string `json:"name"`
	IsReal              bool   `json:"isReal"`
}

type ProcessTopology struct {
	Nodes          []*ProcessNode  `json:"nodes"`
	Calls          []*Call         `json:"calls"`
	DebuggingTrace *DebuggingTrace `json:"debuggingTrace,omitempty"`
}

type ProfileAnalyzation struct {
	Tip   *string             `json:"tip,omitempty"`
	Trees []*ProfileStackTree `json:"trees"`
}

type ProfileAnalyzeTimeRange struct {
	Start int64 `json:"start"`
	End   int64 `json:"end"`
}

type ProfileStackElement struct {
	ID                    string `json:"id"`
	ParentID              string `json:"parentId"`
	CodeSignature         string `json:"codeSignature"`
	Duration              int    `json:"duration"`
	DurationChildExcluded int    `json:"durationChildExcluded"`
	Count                 int    `json:"count"`
}

type ProfileStackTree struct {
	Elements []*ProfileStackElement `json:"elements"`
}

type ProfileTask struct {
	ID                   string            `json:"id"`
	ServiceID            string            `json:"serviceId"`
	ServiceName          string            `json:"serviceName"`
	EndpointName         string            `json:"endpointName"`
	StartTime            int64             `json:"startTime"`
	Duration             int               `json:"duration"`
	MinDurationThreshold int               `json:"minDurationThreshold"`
	DumpPeriod           int               `json:"dumpPeriod"`
	MaxSamplingCount     int               `json:"maxSamplingCount"`
	Logs                 []*ProfileTaskLog `json:"logs"`
}

type ProfileTaskCreationRequest struct {
	ServiceID            string `json:"serviceId"`
	EndpointName         string `json:"endpointName"`
	StartTime            *int64 `json:"startTime,omitempty"`
	Duration             int    `json:"duration"`
	MinDurationThreshold int    `json:"minDurationThreshold"`
	DumpPeriod           int    `json:"dumpPeriod"`
	MaxSamplingCount     int    `json:"maxSamplingCount"`
}

type ProfileTaskCreationResult struct {
	ErrorReason *string `json:"errorReason,omitempty"`
	ID          *string `json:"id,omitempty"`
}

type ProfileTaskLog struct {
	ID            string                      `json:"id"`
	InstanceID    string                      `json:"instanceId"`
	InstanceName  string                      `json:"instanceName"`
	OperationType ProfileTaskLogOperationType `json:"operationType"`
	OperationTime int64                       `json:"operationTime"`
}

type ProfiledSegment struct {
	Spans []*ProfiledSpan `json:"spans"`
}

type ProfiledSpan struct {
	SpanID              int          `json:"spanId"`
	ParentSpanID        int          `json:"parentSpanId"`
	SegmentID           string       `json:"segmentId"`
	Refs                []*Ref       `json:"refs"`
	ServiceCode         string       `json:"serviceCode"`
	ServiceInstanceName string       `json:"serviceInstanceName"`
	StartTime           int64        `json:"startTime"`
	EndTime             int64        `json:"endTime"`
	EndpointName        *string      `json:"endpointName,omitempty"`
	Type                string       `json:"type"`
	Peer                *string      `json:"peer,omitempty"`
	Component           *string      `json:"component,omitempty"`
	IsError             *bool        `json:"isError,omitempty"`
	Layer               *string      `json:"layer,omitempty"`
	Tags                []*KeyValue  `json:"tags"`
	Logs                []*LogEntity `json:"logs"`
	Profiled            bool         `json:"profiled"`
}

type ProfiledTraceSegments struct {
	TraceID       string          `json:"traceId"`
	InstanceID    string          `json:"instanceId"`
	InstanceName  string          `json:"instanceName"`
	EndpointNames []string        `json:"endpointNames"`
	Duration      int             `json:"duration"`
	Start         string          `json:"start"`
	Spans         []*ProfiledSpan `json:"spans"`
}

type Query struct {
}

type Record struct {
	Name  string  `json:"name"`
	ID    string  `json:"id"`
	Value *string `json:"value,omitempty"`
	RefID *string `json:"refId,omitempty"`
}

type RecordCondition struct {
	Name         string  `json:"name"`
	ParentEntity *Entity `json:"parentEntity"`
	TopN         int     `json:"topN"`
	Order        Order   `json:"order"`
}

type RecordsTTL struct {
	Normal              int `json:"normal"`
	Trace               int `json:"trace"`
	ZipkinTrace         int `json:"zipkinTrace"`
	Log                 int `json:"log"`
	BrowserErrorLog     int `json:"browserErrorLog"`
	ColdNormal          int `json:"coldNormal"`
	ColdTrace           int `json:"coldTrace"`
	ColdZipkinTrace     int `json:"coldZipkinTrace"`
	ColdLog             int `json:"coldLog"`
	ColdBrowserErrorLog int `json:"coldBrowserErrorLog"`
}

type Ref struct {
	TraceID         string  `json:"traceId"`
	ParentSegmentID string  `json:"parentSegmentId"`
	ParentSpanID    int     `json:"parentSpanId"`
	Type            RefType `json:"type"`
}

type RetrievedTimeRange struct {
	StartTime int64 `json:"startTime"`
	EndTime   int64 `json:"endTime"`
}

type SegmentProfileAnalyzeQuery struct {
	SegmentID string                   `json:"segmentId"`
	TimeRange *ProfileAnalyzeTimeRange `json:"timeRange"`
}

type SelectedRecord struct {
	Name  string  `json:"name"`
	ID    string  `json:"id"`
	Value *string `json:"value,omitempty"`
	RefID *string `json:"refId,omitempty"`
}

type Service struct {
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	Group     string   `json:"group"`
	ShortName string   `json:"shortName"`
	Layers    []string `json:"layers"`
	Normal    *bool    `json:"normal,omitempty"`
}

type ServiceCondition struct {
	ServiceName string  `json:"serviceName"`
	Layer       *string `json:"layer,omitempty"`
}

type ServiceHierarchy struct {
	Relations []*HierarchyServiceRelation `json:"relations"`
}

type ServiceInstance struct {
	ID           string       `json:"id"`
	Name         string       `json:"name"`
	Attributes   []*Attribute `json:"attributes"`
	Language     Language     `json:"language"`
	InstanceUUID string       `json:"instanceUUID"`
}

type ServiceInstanceNode struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	ServiceID   string  `json:"serviceId"`
	ServiceName string  `json:"serviceName"`
	Type        *string `json:"type,omitempty"`
	IsReal      bool    `json:"isReal"`
}

type ServiceInstanceTopology struct {
	Nodes          []*ServiceInstanceNode `json:"nodes"`
	Calls          []*Call                `json:"calls"`
	DebuggingTrace *DebuggingTrace        `json:"debuggingTrace,omitempty"`
}

type Source struct {
	Service         *string `json:"service,omitempty"`
	ServiceInstance *string `json:"serviceInstance,omitempty"`
	Endpoint        *string `json:"endpoint,omitempty"`
}

type SourceInput struct {
	Service         *string `json:"service,omitempty"`
	ServiceInstance *string `json:"serviceInstance,omitempty"`
	Endpoint        *string `json:"endpoint,omitempty"`
}

type Span struct {
	TraceID             string               `json:"traceId"`
	SegmentID           string               `json:"segmentId"`
	SpanID              int                  `json:"spanId"`
	ParentSpanID        int                  `json:"parentSpanId"`
	Refs                []*Ref               `json:"refs"`
	ServiceCode         string               `json:"serviceCode"`
	ServiceInstanceName string               `json:"serviceInstanceName"`
	StartTime           int64                `json:"startTime"`
	EndTime             int64                `json:"endTime"`
	EndpointName        *string              `json:"endpointName,omitempty"`
	Type                string               `json:"type"`
	Peer                *string              `json:"peer,omitempty"`
	Component           *string              `json:"component,omitempty"`
	IsError             *bool                `json:"isError,omitempty"`
	Layer               *string              `json:"layer,omitempty"`
	Tags                []*KeyValue          `json:"tags"`
	Logs                []*LogEntity         `json:"logs"`
	AttachedEvents      []*SpanAttachedEvent `json:"attachedEvents"`
}

type SpanAttachedEvent struct {
	StartTime *Instant           `json:"startTime"`
	Event     string             `json:"event"`
	EndTime   *Instant           `json:"endTime"`
	Tags      []*KeyValue        `json:"tags"`
	Summary   []*KeyNumericValue `json:"summary"`
}

type SpanTag struct {
	Key   string  `json:"key"`
	Value *string `json:"value,omitempty"`
}

type TemplateChangeStatus struct {
	ID      string  `json:"id"`
	Status  bool    `json:"status"`
	Message *string `json:"message,omitempty"`
}

type Thermodynamic struct {
	Nodes     [][]*int `json:"nodes"`
	AxisYStep int      `json:"axisYStep"`
}

type TimeInfo struct {
	Timezone         *string `json:"timezone,omitempty"`
	CurrentTimestamp *int64  `json:"currentTimestamp,omitempty"`
}

type TopNCondition struct {
	Name          string  `json:"name"`
	ParentService *string `json:"parentService,omitempty"`
	Normal        *bool   `json:"normal,omitempty"`
	Scope         *Scope  `json:"scope,omitempty"`
	TopN          int     `json:"topN"`
	Order         Order   `json:"order"`
}

type TopNEntity struct {
	Name  string `json:"name"`
	ID    string `json:"id"`
	Value int64  `json:"value"`
}

type TopNRecord struct {
	Statement *string `json:"statement,omitempty"`
	Latency   int64   `json:"latency"`
	TraceID   *string `json:"traceId,omitempty"`
}

type TopNRecordsCondition struct {
	ServiceID  string    `json:"serviceId"`
	MetricName string    `json:"metricName"`
	TopN       int       `json:"topN"`
	Order      Order     `json:"order"`
	Duration   *Duration `json:"duration"`
}

type Topology struct {
	Nodes          []*Node         `json:"nodes"`
	Calls          []*Call         `json:"calls"`
	DebuggingTrace *DebuggingTrace `json:"debuggingTrace,omitempty"`
}

type Trace struct {
	Spans          []*Span         `json:"spans"`
	DebuggingTrace *DebuggingTrace `json:"debuggingTrace,omitempty"`
}

type TraceBrief struct {
	Traces         []*BasicTrace   `json:"traces"`
	DebuggingTrace *DebuggingTrace `json:"debuggingTrace,omitempty"`
}

type TraceList struct {
	Traces             []*TraceV2          `json:"traces"`
	RetrievedTimeRange *RetrievedTimeRange `json:"retrievedTimeRange"`
	DebuggingTrace     *DebuggingTrace     `json:"debuggingTrace,omitempty"`
}

type TraceQueryCondition struct {
	ServiceID         *string     `json:"serviceId,omitempty"`
	ServiceInstanceID *string     `json:"serviceInstanceId,omitempty"`
	TraceID           *string     `json:"traceId,omitempty"`
	EndpointID        *string     `json:"endpointId,omitempty"`
	QueryDuration     *Duration   `json:"queryDuration,omitempty"`
	MinTraceDuration  *int        `json:"minTraceDuration,omitempty"`
	MaxTraceDuration  *int        `json:"maxTraceDuration,omitempty"`
	TraceState        TraceState  `json:"traceState"`
	QueryOrder        QueryOrder  `json:"queryOrder"`
	Tags              []*SpanTag  `json:"tags,omitempty"`
	Paging            *Pagination `json:"paging"`
}

type TraceQueryConditionByName struct {
	Service          *ServiceCondition  `json:"service,omitempty"`
	Instance         *InstanceCondition `json:"instance,omitempty"`
	Endpoint         *EndpointCondition `json:"endpoint,omitempty"`
	TraceID          *string            `json:"traceId,omitempty"`
	QueryDuration    *Duration          `json:"queryDuration,omitempty"`
	MinTraceDuration *int               `json:"minTraceDuration,omitempty"`
	MaxTraceDuration *int               `json:"maxTraceDuration,omitempty"`
	TraceState       TraceState         `json:"traceState"`
	QueryOrder       QueryOrder         `json:"queryOrder"`
	Tags             []*SpanTag         `json:"tags,omitempty"`
	Paging           *Pagination        `json:"paging"`
}

type TraceScopeCondition struct {
	TraceID   string  `json:"traceId"`
	SegmentID *string `json:"segmentId,omitempty"`
	SpanID    *int    `json:"spanId,omitempty"`
}

type TraceV2 struct {
	Spans []*Span `json:"spans"`
}

type AsyncProfilerEventType string

const (
	AsyncProfilerEventTypeCPU    AsyncProfilerEventType = "CPU"
	AsyncProfilerEventTypeWall   AsyncProfilerEventType = "WALL"
	AsyncProfilerEventTypeLock   AsyncProfilerEventType = "LOCK"
	AsyncProfilerEventTypeAlloc  AsyncProfilerEventType = "ALLOC"
	AsyncProfilerEventTypeCtimer AsyncProfilerEventType = "CTIMER"
	AsyncProfilerEventTypeItimer AsyncProfilerEventType = "ITIMER"
)

var AllAsyncProfilerEventType = []AsyncProfilerEventType{
	AsyncProfilerEventTypeCPU,
	AsyncProfilerEventTypeWall,
	AsyncProfilerEventTypeLock,
	AsyncProfilerEventTypeAlloc,
	AsyncProfilerEventTypeCtimer,
	AsyncProfilerEventTypeItimer,
}

func (e AsyncProfilerEventType) IsValid() bool {
	switch e {
	case AsyncProfilerEventTypeCPU, AsyncProfilerEventTypeWall, AsyncProfilerEventTypeLock, AsyncProfilerEventTypeAlloc, AsyncProfilerEventTypeCtimer, AsyncProfilerEventTypeItimer:
		return true
	}
	return false
}

func (e AsyncProfilerEventType) String() string {
	return string(e)
}

func (e *AsyncProfilerEventType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AsyncProfilerEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AsyncProfilerEventType", str)
	}
	return nil
}

func (e AsyncProfilerEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AsyncProfilerEventType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AsyncProfilerEventType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AsyncProfilerTaskCreationType string

const (
	AsyncProfilerTaskCreationTypeSuccess               AsyncProfilerTaskCreationType = "SUCCESS"
	AsyncProfilerTaskCreationTypeArgumentError         AsyncProfilerTaskCreationType = "ARGUMENT_ERROR"
	AsyncProfilerTaskCreationTypeAlreadyProfilingError AsyncProfilerTaskCreationType = "ALREADY_PROFILING_ERROR"
)

var AllAsyncProfilerTaskCreationType = []AsyncProfilerTaskCreationType{
	AsyncProfilerTaskCreationTypeSuccess,
	AsyncProfilerTaskCreationTypeArgumentError,
	AsyncProfilerTaskCreationTypeAlreadyProfilingError,
}

func (e AsyncProfilerTaskCreationType) IsValid() bool {
	switch e {
	case AsyncProfilerTaskCreationTypeSuccess, AsyncProfilerTaskCreationTypeArgumentError, AsyncProfilerTaskCreationTypeAlreadyProfilingError:
		return true
	}
	return false
}

func (e AsyncProfilerTaskCreationType) String() string {
	return string(e)
}

func (e *AsyncProfilerTaskCreationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AsyncProfilerTaskCreationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AsyncProfilerTaskCreationType", str)
	}
	return nil
}

func (e AsyncProfilerTaskCreationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AsyncProfilerTaskCreationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AsyncProfilerTaskCreationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AsyncProfilerTaskLogOperationType string

const (
	AsyncProfilerTaskLogOperationTypeNotified                   AsyncProfilerTaskLogOperationType = "NOTIFIED"
	AsyncProfilerTaskLogOperationTypeExecutionFinished          AsyncProfilerTaskLogOperationType = "EXECUTION_FINISHED"
	AsyncProfilerTaskLogOperationTypeJfrUploadFileTooLargeError AsyncProfilerTaskLogOperationType = "JFR_UPLOAD_FILE_TOO_LARGE_ERROR"
	AsyncProfilerTaskLogOperationTypeExecutionTaskError         AsyncProfilerTaskLogOperationType = "EXECUTION_TASK_ERROR"
)

var AllAsyncProfilerTaskLogOperationType = []AsyncProfilerTaskLogOperationType{
	AsyncProfilerTaskLogOperationTypeNotified,
	AsyncProfilerTaskLogOperationTypeExecutionFinished,
	AsyncProfilerTaskLogOperationTypeJfrUploadFileTooLargeError,
	AsyncProfilerTaskLogOperationTypeExecutionTaskError,
}

func (e AsyncProfilerTaskLogOperationType) IsValid() bool {
	switch e {
	case AsyncProfilerTaskLogOperationTypeNotified, AsyncProfilerTaskLogOperationTypeExecutionFinished, AsyncProfilerTaskLogOperationTypeJfrUploadFileTooLargeError, AsyncProfilerTaskLogOperationTypeExecutionTaskError:
		return true
	}
	return false
}

func (e AsyncProfilerTaskLogOperationType) String() string {
	return string(e)
}

func (e *AsyncProfilerTaskLogOperationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AsyncProfilerTaskLogOperationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AsyncProfilerTaskLogOperationType", str)
	}
	return nil
}

func (e AsyncProfilerTaskLogOperationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AsyncProfilerTaskLogOperationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AsyncProfilerTaskLogOperationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ContentType string

const (
	ContentTypeText ContentType = "TEXT"
	ContentTypeJSON ContentType = "JSON"
	ContentTypeYaml ContentType = "YAML"
)

var AllContentType = []ContentType{
	ContentTypeText,
	ContentTypeJSON,
	ContentTypeYaml,
}

func (e ContentType) IsValid() bool {
	switch e {
	case ContentTypeText, ContentTypeJSON, ContentTypeYaml:
		return true
	}
	return false
}

func (e ContentType) String() string {
	return string(e)
}

func (e *ContentType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContentType", str)
	}
	return nil
}

func (e ContentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ContentType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ContentType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ContinuousProfilingMonitorType string

const (
	ContinuousProfilingMonitorTypeProcessCPU          ContinuousProfilingMonitorType = "PROCESS_CPU"
	ContinuousProfilingMonitorTypeProcessThreadCount  ContinuousProfilingMonitorType = "PROCESS_THREAD_COUNT"
	ContinuousProfilingMonitorTypeSystemLoad          ContinuousProfilingMonitorType = "SYSTEM_LOAD"
	ContinuousProfilingMonitorTypeHTTPErrorRate       ContinuousProfilingMonitorType = "HTTP_ERROR_RATE"
	ContinuousProfilingMonitorTypeHTTPAvgResponseTime ContinuousProfilingMonitorType = "HTTP_AVG_RESPONSE_TIME"
)

var AllContinuousProfilingMonitorType = []ContinuousProfilingMonitorType{
	ContinuousProfilingMonitorTypeProcessCPU,
	ContinuousProfilingMonitorTypeProcessThreadCount,
	ContinuousProfilingMonitorTypeSystemLoad,
	ContinuousProfilingMonitorTypeHTTPErrorRate,
	ContinuousProfilingMonitorTypeHTTPAvgResponseTime,
}

func (e ContinuousProfilingMonitorType) IsValid() bool {
	switch e {
	case ContinuousProfilingMonitorTypeProcessCPU, ContinuousProfilingMonitorTypeProcessThreadCount, ContinuousProfilingMonitorTypeSystemLoad, ContinuousProfilingMonitorTypeHTTPErrorRate, ContinuousProfilingMonitorTypeHTTPAvgResponseTime:
		return true
	}
	return false
}

func (e ContinuousProfilingMonitorType) String() string {
	return string(e)
}

func (e *ContinuousProfilingMonitorType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContinuousProfilingMonitorType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContinuousProfilingMonitorType", str)
	}
	return nil
}

func (e ContinuousProfilingMonitorType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ContinuousProfilingMonitorType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ContinuousProfilingMonitorType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ContinuousProfilingTargetType string

const (
	ContinuousProfilingTargetTypeOnCPU   ContinuousProfilingTargetType = "ON_CPU"
	ContinuousProfilingTargetTypeOffCPU  ContinuousProfilingTargetType = "OFF_CPU"
	ContinuousProfilingTargetTypeNetwork ContinuousProfilingTargetType = "NETWORK"
)

var AllContinuousProfilingTargetType = []ContinuousProfilingTargetType{
	ContinuousProfilingTargetTypeOnCPU,
	ContinuousProfilingTargetTypeOffCPU,
	ContinuousProfilingTargetTypeNetwork,
}

func (e ContinuousProfilingTargetType) IsValid() bool {
	switch e {
	case ContinuousProfilingTargetTypeOnCPU, ContinuousProfilingTargetTypeOffCPU, ContinuousProfilingTargetTypeNetwork:
		return true
	}
	return false
}

func (e ContinuousProfilingTargetType) String() string {
	return string(e)
}

func (e *ContinuousProfilingTargetType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContinuousProfilingTargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContinuousProfilingTargetType", str)
	}
	return nil
}

func (e ContinuousProfilingTargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ContinuousProfilingTargetType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ContinuousProfilingTargetType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DetectPoint string

const (
	DetectPointClient DetectPoint = "CLIENT"
	DetectPointServer DetectPoint = "SERVER"
	DetectPointProxy  DetectPoint = "PROXY"
)

var AllDetectPoint = []DetectPoint{
	DetectPointClient,
	DetectPointServer,
	DetectPointProxy,
}

func (e DetectPoint) IsValid() bool {
	switch e {
	case DetectPointClient, DetectPointServer, DetectPointProxy:
		return true
	}
	return false
}

func (e DetectPoint) String() string {
	return string(e)
}

func (e *DetectPoint) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DetectPoint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DetectPoint", str)
	}
	return nil
}

func (e DetectPoint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DetectPoint) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DetectPoint) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type EBPFProfilingAnalyzeAggregateType string

const (
	EBPFProfilingAnalyzeAggregateTypeDuration EBPFProfilingAnalyzeAggregateType = "DURATION"
	EBPFProfilingAnalyzeAggregateTypeCount    EBPFProfilingAnalyzeAggregateType = "COUNT"
)

var AllEBPFProfilingAnalyzeAggregateType = []EBPFProfilingAnalyzeAggregateType{
	EBPFProfilingAnalyzeAggregateTypeDuration,
	EBPFProfilingAnalyzeAggregateTypeCount,
}

func (e EBPFProfilingAnalyzeAggregateType) IsValid() bool {
	switch e {
	case EBPFProfilingAnalyzeAggregateTypeDuration, EBPFProfilingAnalyzeAggregateTypeCount:
		return true
	}
	return false
}

func (e EBPFProfilingAnalyzeAggregateType) String() string {
	return string(e)
}

func (e *EBPFProfilingAnalyzeAggregateType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EBPFProfilingAnalyzeAggregateType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EBPFProfilingAnalyzeAggregateType", str)
	}
	return nil
}

func (e EBPFProfilingAnalyzeAggregateType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EBPFProfilingAnalyzeAggregateType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EBPFProfilingAnalyzeAggregateType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type EBPFProfilingStackType string

const (
	EBPFProfilingStackTypeKernelSpace EBPFProfilingStackType = "KERNEL_SPACE"
	EBPFProfilingStackTypeUserSpace   EBPFProfilingStackType = "USER_SPACE"
)

var AllEBPFProfilingStackType = []EBPFProfilingStackType{
	EBPFProfilingStackTypeKernelSpace,
	EBPFProfilingStackTypeUserSpace,
}

func (e EBPFProfilingStackType) IsValid() bool {
	switch e {
	case EBPFProfilingStackTypeKernelSpace, EBPFProfilingStackTypeUserSpace:
		return true
	}
	return false
}

func (e EBPFProfilingStackType) String() string {
	return string(e)
}

func (e *EBPFProfilingStackType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EBPFProfilingStackType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EBPFProfilingStackType", str)
	}
	return nil
}

func (e EBPFProfilingStackType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EBPFProfilingStackType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EBPFProfilingStackType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type EBPFProfilingTargetType string

const (
	EBPFProfilingTargetTypeOnCPU   EBPFProfilingTargetType = "ON_CPU"
	EBPFProfilingTargetTypeOffCPU  EBPFProfilingTargetType = "OFF_CPU"
	EBPFProfilingTargetTypeNetwork EBPFProfilingTargetType = "NETWORK"
)

var AllEBPFProfilingTargetType = []EBPFProfilingTargetType{
	EBPFProfilingTargetTypeOnCPU,
	EBPFProfilingTargetTypeOffCPU,
	EBPFProfilingTargetTypeNetwork,
}

func (e EBPFProfilingTargetType) IsValid() bool {
	switch e {
	case EBPFProfilingTargetTypeOnCPU, EBPFProfilingTargetTypeOffCPU, EBPFProfilingTargetTypeNetwork:
		return true
	}
	return false
}

func (e EBPFProfilingTargetType) String() string {
	return string(e)
}

func (e *EBPFProfilingTargetType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EBPFProfilingTargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EBPFProfilingTargetType", str)
	}
	return nil
}

func (e EBPFProfilingTargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EBPFProfilingTargetType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EBPFProfilingTargetType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type EBPFProfilingTriggerType string

const (
	EBPFProfilingTriggerTypeFixedTime           EBPFProfilingTriggerType = "FIXED_TIME"
	EBPFProfilingTriggerTypeContinuousProfiling EBPFProfilingTriggerType = "CONTINUOUS_PROFILING"
)

var AllEBPFProfilingTriggerType = []EBPFProfilingTriggerType{
	EBPFProfilingTriggerTypeFixedTime,
	EBPFProfilingTriggerTypeContinuousProfiling,
}

func (e EBPFProfilingTriggerType) IsValid() bool {
	switch e {
	case EBPFProfilingTriggerTypeFixedTime, EBPFProfilingTriggerTypeContinuousProfiling:
		return true
	}
	return false
}

func (e EBPFProfilingTriggerType) String() string {
	return string(e)
}

func (e *EBPFProfilingTriggerType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EBPFProfilingTriggerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EBPFProfilingTriggerType", str)
	}
	return nil
}

func (e EBPFProfilingTriggerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EBPFProfilingTriggerType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EBPFProfilingTriggerType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ErrorCategory string

const (
	ErrorCategoryAll      ErrorCategory = "ALL"
	ErrorCategoryAjax     ErrorCategory = "AJAX"
	ErrorCategoryResource ErrorCategory = "RESOURCE"
	ErrorCategoryVue      ErrorCategory = "VUE"
	ErrorCategoryPromise  ErrorCategory = "PROMISE"
	ErrorCategoryJs       ErrorCategory = "JS"
	ErrorCategoryUnknown  ErrorCategory = "UNKNOWN"
)

var AllErrorCategory = []ErrorCategory{
	ErrorCategoryAll,
	ErrorCategoryAjax,
	ErrorCategoryResource,
	ErrorCategoryVue,
	ErrorCategoryPromise,
	ErrorCategoryJs,
	ErrorCategoryUnknown,
}

func (e ErrorCategory) IsValid() bool {
	switch e {
	case ErrorCategoryAll, ErrorCategoryAjax, ErrorCategoryResource, ErrorCategoryVue, ErrorCategoryPromise, ErrorCategoryJs, ErrorCategoryUnknown:
		return true
	}
	return false
}

func (e ErrorCategory) String() string {
	return string(e)
}

func (e *ErrorCategory) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorCategory", str)
	}
	return nil
}

func (e ErrorCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ErrorCategory) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ErrorCategory) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type EventType string

const (
	EventTypeNormal EventType = "Normal"
	EventTypeError  EventType = "Error"
)

var AllEventType = []EventType{
	EventTypeNormal,
	EventTypeError,
}

func (e EventType) IsValid() bool {
	switch e {
	case EventTypeNormal, EventTypeError:
		return true
	}
	return false
}

func (e EventType) String() string {
	return string(e)
}

func (e *EventType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventType", str)
	}
	return nil
}

func (e EventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EventType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EventType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ExpressionResultType string

const (
	ExpressionResultTypeUnknown          ExpressionResultType = "UNKNOWN"
	ExpressionResultTypeSingleValue      ExpressionResultType = "SINGLE_VALUE"
	ExpressionResultTypeTimeSeriesValues ExpressionResultType = "TIME_SERIES_VALUES"
	ExpressionResultTypeSortedList       ExpressionResultType = "SORTED_LIST"
	ExpressionResultTypeRecordList       ExpressionResultType = "RECORD_LIST"
)

var AllExpressionResultType = []ExpressionResultType{
	ExpressionResultTypeUnknown,
	ExpressionResultTypeSingleValue,
	ExpressionResultTypeTimeSeriesValues,
	ExpressionResultTypeSortedList,
	ExpressionResultTypeRecordList,
}

func (e ExpressionResultType) IsValid() bool {
	switch e {
	case ExpressionResultTypeUnknown, ExpressionResultTypeSingleValue, ExpressionResultTypeTimeSeriesValues, ExpressionResultTypeSortedList, ExpressionResultTypeRecordList:
		return true
	}
	return false
}

func (e ExpressionResultType) String() string {
	return string(e)
}

func (e *ExpressionResultType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExpressionResultType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExpressionResultType", str)
	}
	return nil
}

func (e ExpressionResultType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ExpressionResultType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ExpressionResultType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type JFREventType string

const (
	JFREventTypeExecutionSample             JFREventType = "EXECUTION_SAMPLE"
	JFREventTypeLock                        JFREventType = "LOCK"
	JFREventTypeObjectAllocationInNewTlab   JFREventType = "OBJECT_ALLOCATION_IN_NEW_TLAB"
	JFREventTypeObjectAllocationOutsideTlab JFREventType = "OBJECT_ALLOCATION_OUTSIDE_TLAB"
	JFREventTypeProfilerLiveObject          JFREventType = "PROFILER_LIVE_OBJECT"
)

var AllJFREventType = []JFREventType{
	JFREventTypeExecutionSample,
	JFREventTypeLock,
	JFREventTypeObjectAllocationInNewTlab,
	JFREventTypeObjectAllocationOutsideTlab,
	JFREventTypeProfilerLiveObject,
}

func (e JFREventType) IsValid() bool {
	switch e {
	case JFREventTypeExecutionSample, JFREventTypeLock, JFREventTypeObjectAllocationInNewTlab, JFREventTypeObjectAllocationOutsideTlab, JFREventTypeProfilerLiveObject:
		return true
	}
	return false
}

func (e JFREventType) String() string {
	return string(e)
}

func (e *JFREventType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JFREventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JFREventType", str)
	}
	return nil
}

func (e JFREventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *JFREventType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e JFREventType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type Language string

const (
	LanguageUnknown Language = "UNKNOWN"
	LanguageJava    Language = "JAVA"
	LanguageDotnet  Language = "DOTNET"
	LanguageNodejs  Language = "NODEJS"
	LanguagePython  Language = "PYTHON"
	LanguageRuby    Language = "RUBY"
	LanguageGo      Language = "GO"
	LanguageLua     Language = "LUA"
	LanguagePhp     Language = "PHP"
)

var AllLanguage = []Language{
	LanguageUnknown,
	LanguageJava,
	LanguageDotnet,
	LanguageNodejs,
	LanguagePython,
	LanguageRuby,
	LanguageGo,
	LanguageLua,
	LanguagePhp,
}

func (e Language) IsValid() bool {
	switch e {
	case LanguageUnknown, LanguageJava, LanguageDotnet, LanguageNodejs, LanguagePython, LanguageRuby, LanguageGo, LanguageLua, LanguagePhp:
		return true
	}
	return false
}

func (e Language) String() string {
	return string(e)
}

func (e *Language) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Language(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Language", str)
	}
	return nil
}

func (e Language) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Language) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Language) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MetricsType string

const (
	MetricsTypeUnknown       MetricsType = "UNKNOWN"
	MetricsTypeRegularValue  MetricsType = "REGULAR_VALUE"
	MetricsTypeLabeledValue  MetricsType = "LABELED_VALUE"
	MetricsTypeHeatmap       MetricsType = "HEATMAP"
	MetricsTypeSampledRecord MetricsType = "SAMPLED_RECORD"
)

var AllMetricsType = []MetricsType{
	MetricsTypeUnknown,
	MetricsTypeRegularValue,
	MetricsTypeLabeledValue,
	MetricsTypeHeatmap,
	MetricsTypeSampledRecord,
}

func (e MetricsType) IsValid() bool {
	switch e {
	case MetricsTypeUnknown, MetricsTypeRegularValue, MetricsTypeLabeledValue, MetricsTypeHeatmap, MetricsTypeSampledRecord:
		return true
	}
	return false
}

func (e MetricsType) String() string {
	return string(e)
}

func (e *MetricsType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetricsType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetricsType", str)
	}
	return nil
}

func (e MetricsType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MetricsType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MetricsType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type Order string

const (
	OrderAsc Order = "ASC"
	OrderDes Order = "DES"
)

var AllOrder = []Order{
	OrderAsc,
	OrderDes,
}

func (e Order) IsValid() bool {
	switch e {
	case OrderAsc, OrderDes:
		return true
	}
	return false
}

func (e Order) String() string {
	return string(e)
}

func (e *Order) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Order(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Order", str)
	}
	return nil
}

func (e Order) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Order) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Order) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type PprofEventType string

const (
	PprofEventTypeCPU          PprofEventType = "CPU"
	PprofEventTypeHeap         PprofEventType = "HEAP"
	PprofEventTypeBlock        PprofEventType = "BLOCK"
	PprofEventTypeMutex        PprofEventType = "MUTEX"
	PprofEventTypeGoroutine    PprofEventType = "GOROUTINE"
	PprofEventTypeThreadcreate PprofEventType = "THREADCREATE"
	PprofEventTypeAllocs       PprofEventType = "ALLOCS"
)

var AllPprofEventType = []PprofEventType{
	PprofEventTypeCPU,
	PprofEventTypeHeap,
	PprofEventTypeBlock,
	PprofEventTypeMutex,
	PprofEventTypeGoroutine,
	PprofEventTypeThreadcreate,
	PprofEventTypeAllocs,
}

func (e PprofEventType) IsValid() bool {
	switch e {
	case PprofEventTypeCPU, PprofEventTypeHeap, PprofEventTypeBlock, PprofEventTypeMutex, PprofEventTypeGoroutine, PprofEventTypeThreadcreate, PprofEventTypeAllocs:
		return true
	}
	return false
}

func (e PprofEventType) String() string {
	return string(e)
}

func (e *PprofEventType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PprofEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PprofEventType", str)
	}
	return nil
}

func (e PprofEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PprofEventType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PprofEventType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type PprofTaskCreationType string

const (
	PprofTaskCreationTypeSuccess               PprofTaskCreationType = "SUCCESS"
	PprofTaskCreationTypeArgumentError         PprofTaskCreationType = "ARGUMENT_ERROR"
	PprofTaskCreationTypeAlreadyProfilingError PprofTaskCreationType = "ALREADY_PROFILING_ERROR"
)

var AllPprofTaskCreationType = []PprofTaskCreationType{
	PprofTaskCreationTypeSuccess,
	PprofTaskCreationTypeArgumentError,
	PprofTaskCreationTypeAlreadyProfilingError,
}

func (e PprofTaskCreationType) IsValid() bool {
	switch e {
	case PprofTaskCreationTypeSuccess, PprofTaskCreationTypeArgumentError, PprofTaskCreationTypeAlreadyProfilingError:
		return true
	}
	return false
}

func (e PprofTaskCreationType) String() string {
	return string(e)
}

func (e *PprofTaskCreationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PprofTaskCreationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PprofTaskCreationType", str)
	}
	return nil
}

func (e PprofTaskCreationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PprofTaskCreationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PprofTaskCreationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type PprofTaskLogOperationType string

const (
	PprofTaskLogOperationTypeNotified                     PprofTaskLogOperationType = "NOTIFIED"
	PprofTaskLogOperationTypeExecutionFinished            PprofTaskLogOperationType = "EXECUTION_FINISHED"
	PprofTaskLogOperationTypePprofUploadFileTooLargeError PprofTaskLogOperationType = "PPROF_UPLOAD_FILE_TOO_LARGE_ERROR"
	PprofTaskLogOperationTypeExecutionTaskError           PprofTaskLogOperationType = "EXECUTION_TASK_ERROR"
)

var AllPprofTaskLogOperationType = []PprofTaskLogOperationType{
	PprofTaskLogOperationTypeNotified,
	PprofTaskLogOperationTypeExecutionFinished,
	PprofTaskLogOperationTypePprofUploadFileTooLargeError,
	PprofTaskLogOperationTypeExecutionTaskError,
}

func (e PprofTaskLogOperationType) IsValid() bool {
	switch e {
	case PprofTaskLogOperationTypeNotified, PprofTaskLogOperationTypeExecutionFinished, PprofTaskLogOperationTypePprofUploadFileTooLargeError, PprofTaskLogOperationTypeExecutionTaskError:
		return true
	}
	return false
}

func (e PprofTaskLogOperationType) String() string {
	return string(e)
}

func (e *PprofTaskLogOperationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PprofTaskLogOperationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PprofTaskLogOperationType", str)
	}
	return nil
}

func (e PprofTaskLogOperationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PprofTaskLogOperationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PprofTaskLogOperationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ProfileTaskLogOperationType string

const (
	ProfileTaskLogOperationTypeNotified          ProfileTaskLogOperationType = "NOTIFIED"
	ProfileTaskLogOperationTypeExecutionFinished ProfileTaskLogOperationType = "EXECUTION_FINISHED"
)

var AllProfileTaskLogOperationType = []ProfileTaskLogOperationType{
	ProfileTaskLogOperationTypeNotified,
	ProfileTaskLogOperationTypeExecutionFinished,
}

func (e ProfileTaskLogOperationType) IsValid() bool {
	switch e {
	case ProfileTaskLogOperationTypeNotified, ProfileTaskLogOperationTypeExecutionFinished:
		return true
	}
	return false
}

func (e ProfileTaskLogOperationType) String() string {
	return string(e)
}

func (e *ProfileTaskLogOperationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProfileTaskLogOperationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProfileTaskLogOperationType", str)
	}
	return nil
}

func (e ProfileTaskLogOperationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProfileTaskLogOperationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProfileTaskLogOperationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type QueryOrder string

const (
	QueryOrderByStartTime QueryOrder = "BY_START_TIME"
	QueryOrderByDuration  QueryOrder = "BY_DURATION"
)

var AllQueryOrder = []QueryOrder{
	QueryOrderByStartTime,
	QueryOrderByDuration,
}

func (e QueryOrder) IsValid() bool {
	switch e {
	case QueryOrderByStartTime, QueryOrderByDuration:
		return true
	}
	return false
}

func (e QueryOrder) String() string {
	return string(e)
}

func (e *QueryOrder) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = QueryOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid QueryOrder", str)
	}
	return nil
}

func (e QueryOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *QueryOrder) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e QueryOrder) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type RefType string

const (
	RefTypeCrossProcess RefType = "CROSS_PROCESS"
	RefTypeCrossThread  RefType = "CROSS_THREAD"
)

var AllRefType = []RefType{
	RefTypeCrossProcess,
	RefTypeCrossThread,
}

func (e RefType) IsValid() bool {
	switch e {
	case RefTypeCrossProcess, RefTypeCrossThread:
		return true
	}
	return false
}

func (e RefType) String() string {
	return string(e)
}

func (e *RefType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RefType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RefType", str)
	}
	return nil
}

func (e RefType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RefType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RefType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type Scope string

const (
	ScopeAll                     Scope = "All"
	ScopeService                 Scope = "Service"
	ScopeServiceInstance         Scope = "ServiceInstance"
	ScopeEndpoint                Scope = "Endpoint"
	ScopeProcess                 Scope = "Process"
	ScopeServiceRelation         Scope = "ServiceRelation"
	ScopeServiceInstanceRelation Scope = "ServiceInstanceRelation"
	ScopeEndpointRelation        Scope = "EndpointRelation"
	ScopeProcessRelation         Scope = "ProcessRelation"
)

var AllScope = []Scope{
	ScopeAll,
	ScopeService,
	ScopeServiceInstance,
	ScopeEndpoint,
	ScopeProcess,
	ScopeServiceRelation,
	ScopeServiceInstanceRelation,
	ScopeEndpointRelation,
	ScopeProcessRelation,
}

func (e Scope) IsValid() bool {
	switch e {
	case ScopeAll, ScopeService, ScopeServiceInstance, ScopeEndpoint, ScopeProcess, ScopeServiceRelation, ScopeServiceInstanceRelation, ScopeEndpointRelation, ScopeProcessRelation:
		return true
	}
	return false
}

func (e Scope) String() string {
	return string(e)
}

func (e *Scope) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Scope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Scope", str)
	}
	return nil
}

func (e Scope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Scope) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Scope) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type Step string

const (
	StepDay    Step = "DAY"
	StepHour   Step = "HOUR"
	StepMinute Step = "MINUTE"
	StepSecond Step = "SECOND"
)

var AllStep = []Step{
	StepDay,
	StepHour,
	StepMinute,
	StepSecond,
}

func (e Step) IsValid() bool {
	switch e {
	case StepDay, StepHour, StepMinute, StepSecond:
		return true
	}
	return false
}

func (e Step) String() string {
	return string(e)
}

func (e *Step) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Step(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Step", str)
	}
	return nil
}

func (e Step) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Step) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Step) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TraceState string

const (
	TraceStateAll     TraceState = "ALL"
	TraceStateSuccess TraceState = "SUCCESS"
	TraceStateError   TraceState = "ERROR"
)

var AllTraceState = []TraceState{
	TraceStateAll,
	TraceStateSuccess,
	TraceStateError,
}

func (e TraceState) IsValid() bool {
	switch e {
	case TraceStateAll, TraceStateSuccess, TraceStateError:
		return true
	}
	return false
}

func (e TraceState) String() string {
	return string(e)
}

func (e *TraceState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TraceState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TraceState", str)
	}
	return nil
}

func (e TraceState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TraceState) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TraceState) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
